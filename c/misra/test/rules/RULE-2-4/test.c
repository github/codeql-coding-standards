struct S1 { // COMPLIANT
  int x;
};
struct S2 { // NON_COMPLIANT
  int x;
};
typedef struct S3 { // NON_COMPLIANT
  int x;
} T1;
typedef struct S4 { // COMPLIANT
  int x;
} T2;
struct S5 { // COMPLIANT
  int x;
};
typedef struct S5 T3;
enum E1 { state1, state2 }; // NON_COMPLIANT
enum E2 { state3, state4 }; // COMPLIANT
struct {                    // COMPLIANT - no tag
  int x;
} s6;

void test() {
  struct S1 s1;
  T1 t1;
  t1.x = 0; // Field access on struct S3
  T2 t2;
  struct S4 s4;
  int x = state1; // enum access on E1
  enum E2 e2;
  struct S7 { // NON_COMPLIANT
    int x;
  } s7;
  struct S8 { // COMPLIANT
    int x;
  } s8;
  struct S8 s8_2;

  struct S11 { // COMPLIANT
    int x;
  } foo(struct S11 s);
}

struct S9 { // COMPLIANT
  int x;
} test_2() {
  return (struct S9){0};
}

struct S10 { // NON_COMPLIANT
  int x;
} * test_3() {
  return 0;
}

struct S12 { // COMPLIANT
  int x;
} foo2(struct S12 s);

#define STRUCT_MACRO                                                           \
  struct S13 {                                                                 \
    int x;                                                                     \
  };

void testMacroNameUsed() {
  STRUCT_MACRO // COMPLIANT[FALSE_POSITIVE] - although the struct generated by
               // the macro is never used in this expansion, it may be used in
               // other expansions, so we don't want to report it as unused
}

void testMacroNameNotUsed() {
  STRUCT_MACRO // COMPLIANT - S13 is used in this expansion
      struct S13 s13_2;
}

#define PARTIAL                                                                \
  { int x; }

struct s14 PARTIAL; // NON_COMPLIANT - affected by macro, but not fully
                    // generated, so fair to report as unused

typedef struct {
  int x;
} S15; // COMPLIANT - not a tag