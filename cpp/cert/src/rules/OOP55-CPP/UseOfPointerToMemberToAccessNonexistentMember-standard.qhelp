<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>
   The pointer-to-member operators
   <code>
    .*
   </code>
   and
   <code>
    -&gt;*
   </code>
   are used to obtain an object or a function as though it were a member of an underlying object. For instance, the following are functionally equivalent ways to call the member function
   <code>
    f()
   </code>
   on the object
   <code>
    o
   </code>
   .
  </p>
  <sample language="cpp">
   struct S {
  void f() {}
};

void func() {
  S o;
  void (S::*pm)() = &amp;S::f;
  
  o.f();
  (o.*pm)();
}
  </sample>
  <p>
   The call of the form
   <code>
    o.f()
   </code>
   uses class member access at compile time to look up the address of the function
   <code>
    S::f()
   </code>
   on the object
   <code>
    o
   </code>
   . The call of the form
   <code>
    (o.*pm)()
   </code>
   uses the pointer-to-member operator
   <code>
    .*
   </code>
   to call the function at the address specified by
   <code>
    pm
   </code>
   . In both cases, the object
   <code>
    o
   </code>
   is the implicit
   <code>
    this
   </code>
   object within the member function
   <code>
    S::f()
   </code>
   .
  </p>
  <p>
   The C++ Standard, [expr.mptr.oper], paragraph 4
   [
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
    ISO/IEC 14882-2014
   </a>
   ]
   , states
   the following
   :
  </p>
  <blockquote>
   <p>
    Abbreviating
    <em>
     pm-expression.*cast-expression
    </em>
    as
    <code>
     E1.*E2
    </code>
    ,
    <code>
     E1
    </code>
    is called the
    <em>
     object expression
    </em>
    . If the dynamic type of
    <code>
     E1
    </code>
    does not contain the member to which
    <code>
     E2
    </code>
    refers, the behavior is undefined.
   </p>
  </blockquote>
  <p>
   A pointer-to-member expression of the form
   <code>
    E1-&gt;*E2
   </code>
   is converted to its equivalent form,
   <code>
    (*(E1)).*E2
   </code>
   , so use of pointer-to-member expressions of either form behave equivalently in terms of
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   .
  </p>
  <p>
   Further, the C++ Standard,
   [expr.mptr.oper], paragraph 6, in part, states the following:
  </p>
  <blockquote>
   <p>
    If the second operand is the null pointer to member value, the behavior is undefined.
   </p>
  </blockquote>
  <p>
   Do not use a pointer-to-member expression where the dynamic type of the first operand does not contain the member to which the second operand refers, including the use of a null pointer-to-member value as the second operand.
  </p>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant code example, a pointer-to-member object is obtained from
   <code>
    D::g
   </code>
   but is then upcast to be a
   <code>
    B::*
   </code>
   . When called on an object whose dynamic type is
   <code>
    D
   </code>
   , the pointer-to-member call is well defined. However, the dynamic type of the underlying object is
   <code>
    B
   </code>
   , which results in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   .
  </p>
  <sample language="cpp">
   struct B {
  virtual ~B() = default;
};

struct D : B {
  virtual ~D() = default;
  virtual void g() { /* ... */ }
};

void f() {
  B *b = new B;
 
  // ...
 
  void (B::*gptr)() = static_cast&lt;void(B::*)()&gt;(&amp;D::g);
  (b-&gt;*gptr)();
  delete b;
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution, the upcast is removed, rendering the initial code
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-ill-formed">
    ill-formed
   </a>
   and emphasizing the underlying problem that
   <code>
    B::g()
   </code>
   does not exist. This compliant solution assumes that the programmer's intention was to use the correct dynamic type for the underlying object.
  </p>
  <sample language="cpp">
   struct B {
  virtual ~B() = default;
};

struct D : B {
  virtual ~D() = default;
  virtual void g() { /* ... */ }
};

void f() {
  B *b = new D; // Corrected the dynamic object type.
 
  // ...
  void (D::*gptr)() = &amp;D::g; // Moved static_cast to the next line.
  (static_cast&lt;D *&gt;(b)-&gt;*gptr)();
  delete b;
}
  </sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant code example, a null pointer-to-member value is passed as the second operand to a pointer-to-member expression, resulting in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   .
  </p>
  <sample language="cpp">
   struct B {
  virtual ~B() = default;
};

struct D : B {
  virtual ~D() = default;
  virtual void g() { /* ... */ }
};
 
static void (D::*gptr)(); // Not explicitly initialized, defaults to nullptr.
void call_memptr(D *ptr) {
  (ptr-&gt;*gptr)();
}
 
void f() {
  D *d = new D;
  call_memptr(d);
  delete d;
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution,
   <code>
    gptr
   </code>
   is properly initialized to a valid pointer-to-member value instead of to the default value of
   <code>
    nullptr
   </code>
   .
  </p>
  <sample language="cpp">
   struct B {
  virtual ~B() = default;
};
 
struct D : B {
  virtual ~D() = default;
  virtual void g() { /* ... */ }
};
 
static void (D::*gptr)() = &amp;D::g; // Explicitly initialized.
void call_memptr(D *ptr) {
  (ptr-&gt;*gptr)();
}
 
void f() {
  D *d = new D;
  call_memptr(d);
  delete d;
}
  </sample>
 </section>
 <section title="Risk Assessment">
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      OOP55-CPP
     </td>
     <td>
      High
     </td>
     <td>
      Probable
     </td>
     <td>
      High
     </td>
     <td>
      <strong>
       P6
      </strong>
     </td>
     <td>
      <strong>
       L2
      </strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astrée
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>
       overflow_upon_dereference
       invalid_function_pointer
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">
       Axivion Bauhaus Suite
      </a>
     </td>
     <td>
      7.2.0
     </td>
     <td>
      <strong>
       CertC++-OOP55
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       C++2810, C++2811, C++2812, C++2813, C++2814
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        CERT.OOP.PTR_MEMBER.NO_MEMBER
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       CERT_CPP-OOP55-a
      </strong>
     </td>
     <td>
      A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft Insure++
      </a>
     </td>
     <td>
     </td>
     <td>
     </td>
     <td>
      Runtime detection
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=142409849">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>
       2810, 2811, 2812, 2813, 2814
      </strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>
   Search for other
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerabilities
   </a>
   resulting from the violation of this rule on the
   <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+OOP39-CPP">
    CERT website
   </a>
   .
  </p>
 </section>
 <section title="Related Guidelines">
  <p>
   <em>
    This rule is a subset of
    <a href="https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers">
     EXP34-C. Do not dereference null pointers
    </a>
    .
   </em>
  </p>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 5.5, "Pointer-to-Member Operators"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>