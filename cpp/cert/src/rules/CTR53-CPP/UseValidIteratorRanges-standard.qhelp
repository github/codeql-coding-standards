<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>When iterating over elements of a container, the iterators used must iterate over a valid range. An iterator range is a pair of iterators that refer to the first and past-the-end elements of the range respectively.</p>
  <p>A valid iterator range has all of the following characteristics:</p>
  <ul>
   <li>Both iterators refer into the same container.</li>
   <li>The iterator representing the start of the range precedes the iterator representing the end of the range.</li>
   <li>The iterators are not invalidated, in conformance with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container">CTR51-CPP. Use valid references, pointers, and iterators to reference elements of a container</a>.</li>
  </ul>
  <p>An empty iterator range (where the two iterators are valid and equivalent) is considered to be valid.</p>
  <p>Using a range of two iterators that are invalidated or do not refer into the same container results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant example, the two iterators that delimit the range point into the same container, but the first iterator does not precede the second. On each iteration of its internal loop, <code>std::for_each()</code> compares the first iterator (after incrementing it) with the second for equality; as long as they are not equal, it will continue to increment the first iterator. Incrementing the iterator representing the past-the-end element of the range results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
void f(const std::vector&lt;int&gt; &amp;c) {
  std::for_each(c.end(), c.begin(), [](int i) { std::cout &lt;&lt; i; });
}</sample>
  <p>Invalid iterator ranges can also result from comparison functions that return true for equal values. See <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate">CTR57-CPP. Provide a valid ordering predicate</a> for more information about comparators.</p>
 </section>
 <section title="Compliant Solution">
  <p>In this compliant solution, the iterator values passed to <code>std::for_each()</code> are passed in the proper order.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
void f(const std::vector&lt;int&gt; &amp;c) {
  std::for_each(c.begin(), c.end(), [](int i) { std::cout &lt;&lt; i; });
}</sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, iterators from different containers are passed for the same iterator range. Although many STL <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions">implementations</a> will compile this code and the program may behave as the developer expects, there is no requirement that an STL implementation treat a default-initialized iterator as a synonym for the iterator returned by <code>end()</code>.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
void f(const std::vector&lt;int&gt; &amp;c) {
  std::vector&lt;int&gt;::const_iterator e;
  std::for_each(c.begin(), e, [](int i) { std::cout &lt;&lt; i; });
}</sample>
 </section>
 <section title="Compliant Solution">
  <p>In this compliant solution, the proper iterator generated by a call to <code>end()</code> is passed.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
void f(const std::vector&lt;int&gt; &amp;c) {
  std::for_each(c.begin(), c.end(), [](int i) { std::cout &lt;&lt; i; });
}
</sample>
 </section>
 <section title="Risk Assessment">
  <p>Using an invalid iterator range is similar to allowing a buffer overflow, which can lead to an attacker running arbitrary code.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      CTR53-CPP
     </td>
     <td>
      High
     </td>
     <td>
      Probable
     </td>
     <td>
      High
     </td>
     <td>
      <strong>P6</strong>
     </td>
     <td>
      <strong>L2</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astr√©e
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>overflow_upon_dereference</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar">
       CodeSonar
      </a>
     </td>
     <td>
      6.2p0
     </td>
     <td>
      <strong>LANG.MEM.BO</strong>
     </td>
     <td>
      Buffer Overrun
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++3802</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-CTR53-a</strong>
      <strong>CERT_CPP-CTR53-b</strong>
     </td>
     <td>
      Do not use an iterator range that isn't really a range
      Do not compare iterators from different containers
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>3802 </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">
       PVS-Studio
      </a>
     </td>
     <td>
      7.17
     </td>
     <td>
      <strong>V539<a href="https://pvs-studio.com/en/docs/warnings/v539/"></a></strong>
      ,
      <strong>V662<a href="https://pvs-studio.com/en/docs/warnings/v662/"></a></strong>
      ,
      <strong><a href="https://pvs-studio.com/en/docs/warnings/v789/">V789</a></strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>In <em>Fun with erase()</em>, Chris Rohlf discusses the exploit potential of a program that calls <code>vector::erase()</code> with invalid iterator ranges [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-rohlf2009">Rohlf 2009</a>].</p>
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR53-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR51-CPP.+Use+valid+references%2C+pointers%2C+and+iterators+to+reference+elements+of+a+container">
       CTR51-CPP. Use valid references, pointers, and iterators to reference elements of a container
      </a>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CTR57-CPP.+Provide+a+valid+ordering+predicate">
       CTR57-CPP. Provide a valid ordering predicate
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Clause 24, "Iterators Library"
      Subclause 25.3, "Mutating Sequence Operations"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01">
       Meyers 2001
      </a>
      ]
     </td>
     <td>
      Item 32, "Follow Remove-Like Algorithms with
      <code>erase</code>
      If You Really Want to Remove Something"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>