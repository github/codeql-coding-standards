<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>
   Evaluating a pointer—including dereferencing the pointer, using it as an operand of an arithmetic operation, type casting it, and using it as the right-hand side of an assignment—into memory that has been deallocated by a memory management function is
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   . Pointers to memory that has been deallocated are called
   <em>
    dangling pointers
   </em>
   . Accessing a dangling pointer can result in exploitable
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerabilities
   </a>
   .
  </p>
  <p>
   It is at the memory manager's discretion when to reallocate or recycle the freed memory. When memory is freed, all pointers into it become invalid, and its contents might either be returned to the operating system, making the freed space inaccessible, or remain intact and accessible. As a result, the data at the freed location can appear to be valid but change unexpectedly. Consequently, memory must not be written to or read from once it is freed.
  </p>
 </section>
 <section title="Noncompliant Code Example (new and delete)">
  <p>
   In this noncompliant code example,
   <code>
    s
   </code>
   is dereferenced after it has been deallocated. If this access results in a write-after-free, the
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerability
   </a>
   can be
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit">
    exploited
   </a>
   to run arbitrary code with the permissions of the vulnerable process. Typically, dynamic memory allocations and deallocations are far removed, making it difficult to recognize and diagnose such problems.
  </p>
  <sample language="cpp">
   #include &lt;new&gt;
 
struct S {
  void f();
};
 
void g() noexcept(false) {
  S *s = new S;
  // ...
  delete s;
  // ...
  s-&gt;f();
}
  </sample>
  <p>
   The function
   <code>
    g()
   </code>
   is marked
   <code>
    noexcept(false)
   </code>
   to comply with
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors">
    MEM52-CPP. Detect and handle memory allocation errors
   </a>
   .
  </p>
 </section>
 <section title="Compliant Solution (new and delete)">
  <p>
   In this compliant solution, the dynamically allocated memory is not deallocated until it is no longer required.
  </p>
  <sample language="cpp">
   #include &lt;new&gt;

struct S {
  void f();
};

void g() noexcept(false) {
  S *s = new S;
  // ...
  s-&gt;f();
  delete s;
}
  </sample>
 </section>
 <section title="Compliant Solution (Automatic Storage Duration)">
  <p>
   When possible, use automatic storage duration instead of dynamic storage duration. Since
   <code>
    s
   </code>
   is not required to live beyond the scope of
   <code>
    g()
   </code>
   , this compliant solution uses automatic storage duration to limit the lifetime of
   <code>
    s
   </code>
   to the scope of
   <code>
    g().
   </code>
  </p>
  <sample language="cpp">
   struct S {
  void f();
};

void g() {
  S s;
  // ...
  s.f();
}
  </sample>
 </section>
 <section title="Noncompliant Code Example (std::unique_ptr)">
  <p>
   In the following noncompliant code example, the dynamically allocated memory managed by the
   <code>
    buff
   </code>
   object is accessed after it has been implicitly deallocated by the object's destructor.
  </p>
  <sample language="cpp">
   #include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;cstring&gt;
 
int main(int argc, const char *argv[]) {
  const char *s = "";
  if (argc &gt; 1) {
    enum { BufferSize = 32 };
    try {
      std::unique_ptr&lt;char[]&gt; buff(new char[BufferSize]);
      std::memset(buff.get(), 0, BufferSize);
      // ...
      s = std::strncpy(buff.get(), argv[1], BufferSize - 1);
    } catch (std::bad_alloc &amp;) {
      // Handle error
    }
  }

  std::cout &lt;&lt; s &lt;&lt; std::endl;
}
  </sample>
  <p>
   This code always creates a null-terminated byte string, despite its use of
   <code>
    strncpy()
   </code>
   , because it leaves the final
   <code>
    char
   </code>
   in the buffer set to 0.
  </p>
 </section>
 <section title="Compliant Solution (std::unique_ptr)">
  <p>
   In this compliant solution, the lifetime of the
   <code>
    buff
   </code>
   object extends past the point at which the memory managed by the object is accessed.
  </p>
  <sample language="cpp">
   #include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;cstring&gt;
 
int main(int argc, const char *argv[]) {
  std::unique_ptr&lt;char[]&gt; buff;
  const char *s = "";

  if (argc &gt; 1) {
    enum { BufferSize = 32 };
    try {
      buff.reset(new char[BufferSize]);
      std::memset(buff.get(), 0, BufferSize);
      // ...
      s = std::strncpy(buff.get(), argv[1], BufferSize - 1);
    } catch (std::bad_alloc &amp;) {
      // Handle error
    }
  }

  std::cout &lt;&lt; s &lt;&lt; std::endl;
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution, a variable with automatic storage duration of type
   <code>
    std::string
   </code>
   is used in place of the
   <code>
    std::unique_ptr&lt;char[]&gt;
   </code>
   , which reduces the complexity and improves the security of the solution.
  </p>
  <sample language="cpp">
   #include &lt;iostream&gt;
#include &lt;string&gt;
 
int main(int argc, const char *argv[]) {
  std::string str;

  if (argc &gt; 1) {
    str = argv[1];
  }

  std::cout &lt;&lt; str &lt;&lt; std::endl;
}
  </sample>
 </section>
 <section title="Noncompliant Code Example (std::string::c_str())">
  <p>
   In this noncompliant code example,
   <code>
    std::string::c_str()
   </code>
   is being called on a temporary
   <code>
    std::string
   </code>
   object. The resulting pointer will point to released memory once the
   <code>
    std::string
   </code>
   object is destroyed at the end of the assignment expression, resulting in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   when accessing elements of that pointer.
  </p>
  <sample language="cpp">
   #include &lt;string&gt;
 
std::string str_func();
void display_string(const char *);
 
void f() {
  const char *str = str_func().c_str();
  display_string(str);  /* Undefined behavior */
}
  </sample>
 </section>
 <section title="Compliant solution (std::string::c_str())">
  <p>
   In this compliant solution, a local copy of the string returned by
   <code>
    str_func()
   </code>
   is made to ensure that string
   <code>
    str
   </code>
   will be valid when the call to
   <code>
    display_string()
   </code>
   is made.
  </p>
  <sample language="cpp">
   #include &lt;string&gt;
 
std::string str_func();
void display_string(const char *s);

void f() {
  std::string str = str_func();
  const char *cstr = str.c_str();
  display_string(cstr);  /* ok */
}
  </sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant code example, an attempt is made to allocate zero bytes of memory through a call to
   <code>
    operator new()
   </code>
   . If this request succeeds,
   <code>
    operator new()
   </code>
   is required to return a non-null pointer value. However, according to the C++ Standard, [basic.stc.dynamic.allocation], paragraph 2 [
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
    ISO/IEC 14882-2014
   </a>
   ], attempting to dereference memory through such a pointer results in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   .
  </p>
  <sample language="cpp">
   #include &lt;new&gt;

void f() noexcept(false) {
  unsigned char *ptr = static_cast&lt;unsigned char *&gt;(::operator new(0));
  *ptr = 0;
  // ...
  ::operator delete(ptr);
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   The compliant solution depends on programmer intent. If the programmer intends to allocate a single
   <code>
    unsigned char
   </code>
   object, the compliant solution is to use
   <code>
    new
   </code>
   instead of a direct call to
   <code>
    operator new()
   </code>
   , as this compliant solution demonstrates.
  </p>
  <sample language="cpp">
   void f() noexcept(false) {
  unsigned char *ptr = new unsigned char;
  *ptr = 0;
  // ...
  delete ptr;
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   If the programmer intends to allocate zero bytes of memory (perhaps to obtain a unique pointer value that cannot be reused by any other pointer in the program until it is properly released), then instead of attempting to dereference the resulting pointer, the recommended solution is to declare
   <code>
    ptr
   </code>
   as a
   <code>
    void *
   </code>
   , which cannot be dereferenced by a
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-conformingprogram">
    conforming
   </a>
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation">
    implementation
   </a>
   .
  </p>
  <sample language="cpp">
   #include &lt;new&gt;

void f() noexcept(false) {
  void *ptr = ::operator new(0);
  // ...
  ::operator delete(ptr);
}
  </sample>
 </section>
 <section title="Risk Assessment">
  <p>
   Reading previously dynamically allocated memory after it has been deallocated can lead to
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-abnormaltermination">
    abnormal program termination
   </a>
   and
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-denial-of-service">
    denial-of-service attacks
   </a>
   . Writing memory that has been deallocated can lead to the execution of arbitrary code with the permissions of the vulnerable process.
  </p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      MEM50-CPP
     </td>
     <td>
      High
     </td>
     <td>
      Likely
     </td>
     <td>
      Medium
     </td>
     <td>
      <strong>
       P18
      </strong>
     </td>
     <td>
      <strong>
       L1
      </strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astrée
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>
       dangling_pointer_use
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">
       Axivion Bauhaus Suite
      </a>
     </td>
     <td>
      7.2.0
     </td>
     <td>
      <strong>
       CertC++-MEM50
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang">
       Clang
      </a>
     </td>
     <td>
      3.9
     </td>
     <td>
      <code>
       clang-analyzer-cplusplus.NewDelete
       clang-analyzer-alpha.security.ArrayBoundV2
      </code>
     </td>
     <td>
      Checked by
      <code>
       clang-tidy
      </code>
      , but does not catch all violations of this rule.
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar">
       CodeSonar
      </a>
     </td>
     <td>
      6.1p0
     </td>
     <td>
      <strong>
       ALLOC.UAF
      </strong>
     </td>
     <td>
      Use after free
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Rose">
       Compass/ROSE
      </a>
     </td>
     <td>
     </td>
     <td>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/Coverity">
       Coverity
      </a>
     </td>
     <td>
      v7.5.0
     </td>
     <td>
      <strong>
       USE_AFTER_FREE
      </strong>
     </td>
     <td>
      Can detect the specific instances where memory is deallocated more than once or read/written to the target of a freed pointer
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       C++4303, C++4304
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.DEREF.MIGHT
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.DEREF.MUST
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.FFM.MIGHT
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.FFM.MUST
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.RETURN.MIGHT
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.RETURN.MUST
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.USE.MIGHT
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        UFM.USE.MUST
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>
       483 S, 484 S
      </strong>
     </td>
     <td>
      Partially implemented
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       CERT_CPP-MEM50-a
      </strong>
     </td>
     <td>
      Do not use resources that have been freed
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft Insure++
      </a>
     </td>
     <td>
     </td>
     <td>
     </td>
     <td>
      Runtime detection
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcmem50cpp.html">
       CERT C++: MEM50-CPP
      </a>
     </td>
     <td>
      Checks for:
      Pointer access out of bounds, deallocation of previously deallocated pointer, use of previously freed pointer.
      Rule partially covered.
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=142409849">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>
       4303, 4304
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">
       PVS-Studio
      </a>
     </td>
     <td>
      7.16
     </td>
     <td>
      <strong>
       V586
       <a href="https://pvs-studio.com/en/docs/warnings/v586/">
       </a>
      </strong>
      ,
      <strong>
       <a href="https://pvs-studio.com/en/docs/warnings/v774/">
        V774
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Splint">
       Splint
      </a>
     </td>
     <td>
     </td>
     <td>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>
   VU#623332 describes a double-free vulnerability in the MIT Kerberos 5 function
   <a href="http://web.mit.edu/kerberos/www/advisories/MITKRB5-SA-2005-003-recvauth.txt">
    krb5_recvauth()
   </a>
   [
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-VU623332">
    VU# 623332
   </a>
   ].
  </p>
  <p>
   Search for other
   <a href="https://wiki.sei.cmu.edu/confluence/display/c/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerabilities
   </a>
   resulting from the violation of this rule on the
   <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+MEM30-CPP">
    CERT website
   </a>
   .
  </p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP54-CPP.+Do+not+access+an+object+outside+of+its+lifetime">
       EXP54-CPP. Do not access an object outside of its lifetime
      </a>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors">
       MEM52-CPP. Detect and handle memory allocation errors
      </a>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">
       SEI CERT C Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory">
       MEM30-C. Do not access freed memory
      </a>
     </td>
    </tr>
    <tr>
     <td>
      <a href="http://cwe.mitre.org/">
       MITRE CWE
      </a>
     </td>
     <td>
      <a href="http://cwe.mitre.org/data/definitions/415.html">
       CWE-415
      </a>
      , Double Free
      <a href="http://cwe.mitre.org/data/definitions/416.html">
       CWE-416
      </a>
      , Use After Free
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 3.7.4.1, "Allocation Functions"
      Subclause
      3.7.4.2, "Deallocation Functions"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/AA.+Bibliography#AA.Bibliography-Seacord2013">
       Seacord 2013b
      </a>
      ]
     </td>
     <td>
      Chapter 4, "Dynamic Memory Management"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>