<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>While rule <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function">DCL50-CPP. Do not define a C-style variadic function</a> forbids creation of such functions, they may still be defined when that function has external, C language linkage. Under these circumstances, care must be taken when invoking the <code>va_start()</code> macro. The C-standard library macro <code>va_start()</code> imposes several semantic restrictions on the type of the value of its second parameter. The C Standard, subclause 7.16.1.4, paragraph 4 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO-IEC9899-2011">ISO/IEC 9899:2011</a>], states the following:</p>
  <blockquote>
   <p>The parameter <em>parmN</em> is the identifier of the rightmost parameter in the variable parameter list in the function definition (the one just before the <code>...</code>). If the parameter <em>parmN</em> is declared with the <code>register</code> storage class, with a function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions, the behavior is undefined.</p>
  </blockquote>
  <p>These restrictions are superseded by the C++ Standard, [support.runtime], paragraph 3 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], which states the following:</p>
  <blockquote>
   <p>The restrictions that ISO C places on the second parameter to the <code>va_start()</code> macro in header <code>&lt;stdarg.h&gt;</code> are different in this International Standard. The parameter <code>parmN</code> is the identifier of the rightmost parameter in the variable parameter list of the function definition (the one just before the <code>...</code>). If the parameter <code>parmN</code> is of a reference type, or of a type that is not compatible with the type that results when passing an argument for which there is no parameter, the behavior is undefined.</p>
  </blockquote>
  <p>The primary differences between the semantic requirements are as follows:</p>
  <ul>
   <li>You must not pass a reference as the second argument to <code>va_start()</code>.</li>
   <li>Passing an object of a class type that has a nontrivial copy constructor, nontrivial move constructor, or nontrivial destructor as the second argument to <code>va_start</code> is conditionally supported with implementation-defined semantics ([expr.call] paragraph 7).</li>
   <li>You may pass a parameter declared with the <code>register</code> keyword ([dcl.stc] paragraph 3) or a parameter with a function type.</li>
  </ul>
  <p>Passing an object of array type still produces <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> in C++ because an array type as a function parameter requires the use of a reference, which is prohibited. Additionally, passing an object of a type that undergoes default argument promotions still produces undefined behavior in C++.</p>
  <p>Noncompliant Code Example</p>
  <p>In this noncompliant code example, the object passed to <code>va_start()</code> will undergo a default argument promotion, which results in undefined behavior.</p>
  <sample language="cpp">#include &lt;cstdarg&gt;
 
extern "C" void f(float a, ...) {
  va_list list;
  va_start(list, a);
  // ...
  va_end(list);
}</sample>
 </section>
 <section title="Compliant Solution">
  <p>In this compliant solution, <code>f()</code> accepts a <code>double</code> instead of a <code>float.</code></p>
  <sample language="cpp">#include &lt;cstdarg&gt;
 
extern "C" void f(double a, ...) {
  va_list list;
  va_start(list, a);
  // ...
  va_end(list);
}
</sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, a reference type is passed as the second argument to <code>va_start().</code></p>
  <sample language="cpp">#include &lt;cstdarg&gt;
#include &lt;iostream&gt;
 
extern "C" void f(int &amp;a, ...) {
  va_list list;
  va_start(list, a);
  if (a) {
    std::cout &lt;&lt; a &lt;&lt; ", " &lt;&lt; va_arg(list, int);
    a = 100; // Assign something to a for the caller
  }
  va_end(list);
}</sample>
 </section>
 <section title="Compliant Solution">
  <p>Instead of passing a reference type to <code>f()</code>, this compliant solution passes a pointer type.</p>
  <sample language="cpp">#include &lt;cstdarg&gt;
#include &lt;iostream&gt;
 
extern "C" void f(int *a, ...) {
  va_list list;
  va_start(list, a);
  if (a &amp;&amp; *a) {
    std::cout &lt;&lt; a &lt;&lt; ", " &lt;&lt; va_arg(list, int);
    *a = 100; // Assign something to *a for the caller
  }
  va_end(list);
}
</sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, a class with a nontrivial copy constructor (<code>std::string</code>) is passed as the second argument to <code>va_start()</code>, which is conditionally supported depending on the <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation">implementation</a>.</p>
  <sample language="cpp">#include &lt;cstdarg&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
 
extern "C" void f(std::string s, ...) {
  va_list list;
  va_start(list, s);
  std::cout &lt;&lt; s &lt;&lt; ", " &lt;&lt; va_arg(list, int);
  va_end(list);
}</sample>
 </section>
 <section title="Compliant Solution">
  <p>This compliant solution passes a <code>const char *</code> instead of a <code>std::string</code>, which has well-defined behavior on all implementations.</p>
  <sample language="cpp">#include &lt;cstdarg&gt;
#include &lt;iostream&gt;
 
extern "C" void f(const char *s, ...) {
  va_list list;
  va_start(list, s);
  std::cout &lt;&lt; (s ? s : "") &lt;&lt; ", " &lt;&lt; va_arg(list, int);
  va_end(list);
}</sample>
 </section>
 <section title="Risk Assessment">
  <p>Passing an object of an unsupported type as the second argument to <code>va_start()</code> can result in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> that might be <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit">exploited</a> to cause data integrity violations.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      EXP58-CPP
     </td>
     <td>
      Medium
     </td>
     <td>
      Unlikely
     </td>
     <td>
      Medium
     </td>
     <td>
      <strong>P4</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang">
       Clang
      </a>
     </td>
     <td>
      3.9
     </td>
     <td>
      <code>-Wvarargs</code>
     </td>
     <td>
      Does not catch the violation in the third noncompliant code example (it is conditionally supported by
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-Clang">
       Clang
      </a>
      )
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++3852, C++3853</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-EXP58-a</strong>
     </td>
     <td>
      Use macros for variable arguments correctly
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcexp58cpp.html">
       CERT C++: EXP58-CPP
      </a>
     </td>
     <td>
      Checks for incorrect data types for second argument of va_start (rule fully covered)
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+EXP40-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function">
       DCL50-CPP. Do not define a C-style variadic function
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO-IEC9899-2011">
       ISO/IEC 9899:2011
      </a>
      ]
     </td>
     <td>
      Subclause 7.16.1.4, "The
      <code>va_start</code>
      Macro"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 18.10, "Other Runtime Support"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>