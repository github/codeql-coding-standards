<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>
   The C++ Standard, [expr.delete], paragraph 3
   [
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
    ISO/IEC 14882-2014
   </a>
   ],
   states the following:
  </p>
  <blockquote>
   <p>
    In the first alternative (
    <em>
     delete object
    </em>
    ), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (
    <em>
     delete array
    </em>
    ) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.
   </p>
  </blockquote>
  <p>
   Do not delete an object of derived class type through a pointer to its base class type that has a non-
   <code>
    virtual
   </code>
   destructor. Instead, the base class should be defined with a
   <code>
    virtual
   </code>
   destructor. Deleting an object through a pointer to a type without a
   <code>
    virtual
   </code>
   destructor results in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   .
  </p>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant example,
   <code>
    b
   </code>
   is a polymorphic pointer type whose static type is
   <code>
    Base *
   </code>
   and whose dynamic type is
   <code>
    Derived *
   </code>
   . When
   <code>
    b
   </code>
   is deleted, it results in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   because
   <code>
    Base
   </code>
   does not have a
   <code>
    virtual
   </code>
   destructor. The C++ Standard, [class.dtor], paragraph 4
   [
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
    ISO/IEC 14882-2014
   </a>
   ], states the following
   :
  </p>
  <blockquote>
   <p>
    If a class has no user-declared destructor, a destructor is implicitly declared as defaulted. An implicitly declared destructor is an
    <code>
     inline public
    </code>
    member of its class.
   </p>
  </blockquote>
  <p>
   The implicitly declared destructor is not declared as
   <code>
    virtual
   </code>
   even in the presence of other
   <code>
    virtual
   </code>
   functions.
  </p>
  <sample language="cpp">
   struct Base {
  virtual void f();
};
 
struct Derived : Base {};
 
void f() {
  Base *b = new Derived();
  // ...
  delete b;
}
  </sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant example, the explicit pointer operations have been replaced with a smart pointer object, demonstrating that smart pointers suffer from the same problem as other pointers. Because the default deleter for
   <code>
    std::unique_ptr
   </code>
   calls
   <code>
    delete
   </code>
   on the internal pointer value, the resulting behavior is identical to the previous noncompliant example.
  </p>
  <sample language="cpp">
   #include &lt;memory&gt;
 
struct Base {
  virtual void f();
};
 
struct Derived : Base {};
 
void f() {
  std::unique_ptr&lt;Base&gt; b = std::make_unique&lt;Derived()&gt;();
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution, the destructor for
   <code>
    Base
   </code>
   has an explicitly declared
   <code>
    virtual
   </code>
   destructor, ensuring that the polymorphic delete operation results in well-defined behavior.
  </p>
  <sample language="cpp">
   struct Base {
  virtual ~Base() = default;
  virtual void f();
};

struct Derived : Base {};

void f() {
  Base *b = new Derived();
  // ...
  delete b;
}
  </sample>
 </section>
 <section title="Exceptions">
  <p>
   <strong>
    OOP52-CPP:EX0
   </strong>
   : Deleting a polymorphic object without a virtual destructor is permitted if the object is referenced by a pointer to its class, rather than via a pointer to a class it inherits from.
  </p>
  <sample language="cpp">
   class Base {
public:
  // ...
  virtual void AddRef() = 0;
  virtual void Destroy() = 0;
};

class Derived final : public Base {
public:
  // ...
  virtual void AddRef() { /* ... */ }
  virtual void Destroy() { delete this; }
private:
  ~Derived() {}
};
  </sample>
  <p>
   Note that if
   <code>
    Derived
   </code>
   were not marked as
   <code>
    final
   </code>
   , then
   <code>
    delete this
   </code>
   could actually reference a subclass of
   <code>
    Derived
   </code>
   , violating this rule.
  </p>
  <p>
   <strong>
    OOP52-CPP:EX1
   </strong>
   : Deleting a polymorphic object without a virtual destructor is permitted if its base class has a destroying
   <code>
    operator delete
   </code>
   that will figure out the correct derived class's destructor to call by other means.
  </p>
  <sample language="cpp">
   #include &lt;new&gt;

class Base {
  const int whichDerived;

protected:
  Base(int whichDerived) : whichDerived(whichDerived) {}

public:
  Base() : Base(0) {}
  void operator delete(Base *, std::destroying_delete_t);
};

struct Derived1 final : Base {
  Derived1() : Base(1) {}
};

struct Derived2 final : Base {
  Derived2() : Base(2) {}
};

void Base::operator delete(Base *b, std::destroying_delete_t) {
  switch (b-&gt;whichDerived) {
  case 0:
    b-&gt;~Base();
    break;
  case 1:
    static_cast&lt;Derived1 *&gt;(b)-&gt;~Derived1();
    break;
  case 2:
    static_cast&lt;Derived2 *&gt;(b)-&gt;~Derived2();
  }
  ::operator delete(b);
}

void f() {
  Base *b = new Derived1();
  // ...
  delete b;
}
  </sample>
 </section>
 <section title="Risk Assessment">
  <p>
   Attempting to destruct a polymorphic object that does not have a
   <code>
    virtual
   </code>
   destructor declared results in
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">
    undefined behavior
   </a>
   . In practice, potential consequences include
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-abnormaltermination">
    abnormal program termination
   </a>
   and memory leaks.
  </p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      OOP52-CPP
     </td>
     <td>
      Low
     </td>
     <td>
      Likely
     </td>
     <td>
      Low
     </td>
     <td>
      <strong>
       P9
      </strong>
     </td>
     <td>
      <strong>
       L2
      </strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astrée
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>
       non-virtual-public-destructor-in-non-final-class
      </strong>
     </td>
     <td>
      Partially checked
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">
       Axivion Bauhaus Suite
      </a>
     </td>
     <td>
      7.2.0
     </td>
     <td>
      <strong>
       CertC++-OOP52
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang">
       Clang
      </a>
     </td>
     <td>
      3.9
     </td>
     <td>
      <code>
       -Wdelete-non-virtual-dtor
      </code>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       C++3402, C++3403, C++3404
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        CL.MLK.VIRTUAL
       </a>
      </strong>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        CWARN.DTOR.NONVIRT.DELETE
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>
       303 S
      </strong>
     </td>
     <td>
      Partially implemented
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       CERT_CPP-OOP52-a
      </strong>
     </td>
     <td>
      Define a virtual destructor in classes used as base classes which have virtual functions
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>
       3402, 3403, 3404
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcoop52cpp.html">
       CERT C++: OOP52-CPP
      </a>
     </td>
     <td>
      Checks for situations when a class has virtual functions but not a virtual destructor (rule partially covered)
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">
       PVS-Studio
      </a>
     </td>
     <td>
      7.16
     </td>
     <td>
      <strong>
       V599
       <a href="https://pvs-studio.com/en/docs/warnings/v599/">
       </a>
      </strong>
      ,
      <strong>
       <a href="https://pvs-studio.com/en/docs/warnings/v689/">
        V689
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/RuleChecker">
       RuleChecker
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>
       non-virtual-public-destructor-in-non-final-class
      </strong>
     </td>
     <td>
      Partially checked
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046388">
       SonarQube C/C++ Plugin
      </a>
     </td>
     <td>
      4.10
     </td>
     <td>
      <strong>
       <a href="https://www.sonarsource.com/products/codeanalyzers/sonarcfamilyforcpp/rules-cpp.html#RSPEC-1235">
        S1235
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>
   Search for other
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerabilities
   </a>
   resulting from the violation of this rule on the
   <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+OOP52-CPP">
    CERT website
   </a>
   .
  </p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type">
       EXP51-CPP. Do not delete an array through a pointer of the incorrect type
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 5.3.5, "Delete"
      Subclause 12.4, "Destructors"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Stroustrup06">
       Stroustrup 2006
      </a>
      ]
     </td>
     <td>
      "Why Are Destructors Not Virtual by Default?"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>