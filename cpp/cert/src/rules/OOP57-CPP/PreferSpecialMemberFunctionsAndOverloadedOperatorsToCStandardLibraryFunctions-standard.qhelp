<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>
   Several C standard library functions perform bytewise operations on objects. For instance,
   <code>
    std::memcmp()
   </code>
   compares the bytes comprising the object representation of two objects, and
   <code>
    std::memcpy()
   </code>
   copies the bytes comprising an object representation into a destination buffer. However, for some object types, it results in undefined or abnormal program behavior.
  </p>
  <p>
   The C++ Standard, [class], paragraph 6 [
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
    ISO/IEC 14882-2014
   </a>
   ], states the following:
  </p>
  <blockquote>
   <p>
    A
    <em>
     trivially copyable class
    </em>
    is a class that:
    — has no non-trivial copy constructors,
    — has no non-trivial move constructors,
    — has no non-trivial copy assignment operators,
    — has no non-trivial move assignment operators, and
    — has a trivial destructor.
    A
    <em>
     trivial class
    </em>
    is a class that has a default constructor, has no non-trivial default constructors, and is trivially copyable.
    [
    Note:
    In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes.
    — end note
    ]
   </p>
  </blockquote>
  <p>
   Additionally, the C++ Standard, [class], paragraph 7, states the following:
  </p>
  <blockquote>
   <p>
    A
    <em>
     standard-layout class
    </em>
    is a class that:
    — has no non-static data members of type non-standard-layout class (or array of such types) or reference,
    — has no virtual functions and no virtual base classes,
    — has the same access control for all non-static data members,
    — has no non-standard-layout base classes,
    — either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and
    — has no base classes of the same type as the first non-static data member.
   </p>
  </blockquote>
  <p>
   Do not use
   <code>
    std::memset()
   </code>
   to initialize an object of nontrivial class type as it may not properly initialize the value representation of the object. Do not use
   <code>
    std::memcpy()
   </code>
   (or related bytewise copy functions) to initialize a copy of an object of nontrivial class type, as it may not properly initialize the value representation of the copy. Do not use
   <code>
    std::memcmp()
   </code>
   (or related bytewise comparison functions) to compare objects of nonstandard-layout class type, as it may not properly compare the value representations of the objects. In all cases, it is best to prefer the alternatives.
  </p>
  <table>
   <tbody>
    <tr>
     <th>
      C Standard Library Function
     </th>
     <th>
      C++ Equivalent Functionality
     </th>
    </tr>
    <tr>
     <td>
      <code>
       std::memset()
      </code>
     </td>
     <td>
      Class constructor
     </td>
    </tr>
    <tr>
     <td>
      <code>
       std::memcpy()
      </code>
      <code>
       std::memmove()
      </code>
      <code>
       std::strcpy()
      </code>
     </td>
     <td>
      Class copy constructor or
      <code>
       operator=()
      </code>
     </td>
    </tr>
    <tr>
     <td>
      <code>
       std::memcmp()
      </code>
      <code>
       std::strcmp()
      </code>
     </td>
     <td>
      <code>
       operator&lt;()
      </code>
      ,
      <code>
       operator&gt;()
      </code>
      ,
      <code>
       operator==()
      </code>
      , or
      <code>
       operator!=()
      </code>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant code example, a nontrivial class object is initialized by calling its default constructor but is later reinitialized to its default state using
   <code>
    std::memset()
   </code>
   , which does not properly reinitialize the object. Improper reinitialization leads to class invariants not holding in later uses of the object.
  </p>
  <sample language="cpp">
   #include &lt;cstring&gt;
#include &lt;iostream&gt;
 
class C {
  int scalingFactor;
  int otherData;
 
public:
  C() : scalingFactor(1) {}
  
  void set_other_data(int i);
  int f(int i) {
    return i / scalingFactor;
  }
  // ...
};
 
void f() {
  C c;
  
  // ... Code that mutates c ... 
  
  // Reinitialize c to its default state
  std::memset(&amp;c, 0, sizeof(C));
  
  std::cout &lt;&lt; c.f(100) &lt;&lt; std::endl;
}
  </sample>
  <p>
   The above noncompliant code example is compliant with
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP62-CPP.+Do+not+access+the+bits+of+an+object+representation+that+are+not+part+of+the+object%27s+value+representation">
    EXP62-CPP. Do not access the bits of an object representation that are not part of the object's value representation
   </a>
   because all of the bits in the value representation are also used in the object representation of
   <code>
    C
   </code>
   .
  </p>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution, the call to
   <code>
    std::memset()
   </code>
   is replaced with a default-initialized copy-and-swap operation called
   <code>
    clear()
   </code>
   . This operation ensures that the object is initialized to its default state properly, and it behaves properly for object types that have optimized assignment operators that fail to clear all data members of the object being assigned into.
  </p>
  <sample language="cpp">
   #include &lt;iostream&gt;
#include &lt;utility&gt;
 
class C {
  int scalingFactor;
  int otherData;
 
public:
  C() : scalingFactor(1) {}
  
  void set_other_data(int i);
  int f(int i) {
    return i / scalingFactor;
  }
  // ...
};
 
template &lt;typename T&gt;
T&amp; clear(T &amp;o) {
  using std::swap;
  T empty;
  swap(o, empty);
  return o;
}

void f() {
  C c;
  
  // ... Code that mutates c ... 
  
  // Reinitialize c to its default state
  clear(c);
  
  std::cout &lt;&lt; c.f(100) &lt;&lt; std::endl;
}
  </sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant code example,
   <code>
    std::memcpy()
   </code>
   is used to create a copy of an object of nontrivial type
   <code>
    C
   </code>
   . However, because each object instance attempts to delete the
   <code>
    int *
   </code>
   in
   <code>
    C::~C()
   </code>
   , double-free
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerabilities
   </a>
   may occur because the same pointer value will be copied into
   <code>
    c2
   </code>
   .
  </p>
  <sample language="cpp">
   #include &lt;cstring&gt;
 
class C {
  int *i;
 
public:
  C() : i(nullptr) {}
  ~C() { delete i; }
 
  void set(int val) {
    if (i) { delete i; }
    i = new int{val};
  }
 
  // ...
};
 
void f(C &amp;c1) {
  C c2;
  std::memcpy(&amp;c2, &amp;c1, sizeof(C));  
}
  </sample>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution,
   <code>
    C
   </code>
   defines an assignment operator that is used instead of calling
   <code>
    std::memcpy()
   </code>
   .
  </p>
  <sample language="cpp">
   class C {
  int *i;
 
public:
  C() : i(nullptr) {}
  ~C() { delete i; }
 
  void set(int val) {
    if (i) { delete i; }
    i = new int{val};
  }

  C &amp;operator=(const C &amp;rhs) noexcept(false) {
    if (this != &amp;rhs) {
      int *o = nullptr;
      if (rhs.i) {
        o = new int;
        *o = *rhs.i;
      }
      // Does not modify this unless allocation succeeds.
      delete i;
      i = o;
    }
    return *this;
  }
 
  // ...
};
 
void f(C &amp;c1) {
  C c2 = c1;
}
  </sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>
   In this noncompliant code example,
   <code>
    std::memcmp()
   </code>
   is used to compared two objects of nonstandard-layout type. Because
   <code>
    std::memcmp()
   </code>
   performs a bytewise comparison of the object representations, if the implementation uses a vtable pointer as part of the object representation, it will compare vtable pointers. If the dynamic type of either
   <code>
    c1
   </code>
   or
   <code>
    c2
   </code>
   is a derived class of type
   <code>
    C
   </code>
   , the comparison may fail despite the value representation of either object.
  </p>
  <sample language="cpp">
   #include &lt;cstring&gt;
 
class C {
  int i;
 
public:
  virtual void f();
  
  // ...
};
 
void f(C &amp;c1, C &amp;c2) {
  if (!std::memcmp(&amp;c1, &amp;c2, sizeof(C))) {
    // ...
  }
}
  </sample>
  <p>
   Because a vtable is not part of an object's value representation, comparing it with
   <code>
    std::memcmp()
   </code>
   also violates
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP62-CPP.+Do+not+access+the+bits+of+an+object+representation+that+are+not+part+of+the+object%27s+value+representation">
    EXP62-CPP. Do not access the bits of an object representation that are not part of the object's value representation
   </a>
   .
  </p>
 </section>
 <section title="Compliant Solution">
  <p>
   In this compliant solution,
   <code>
    C
   </code>
   defines an equality operator that is used instead of calling
   <code>
    std::memcmp()
   </code>
   . This solution ensures that only the value representation of the objects is considered when performing the comparison.
  </p>
  <sample language="cpp">
   class C {
  int i;
 
public:
  virtual void f();
  
  bool operator==(const C &amp;rhs) const {
    return rhs.i == i;
  }

  // ...
};
 
void f(C &amp;c1, C &amp;c2) {
  if (c1 == c2) {
    // ...
  }
}
  </sample>
 </section>
 <section title="Risk Assessment">
  <p>
   Most violations of this rule will result in abnormal program behavior. However, overwriting
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions">
    implementation
   </a>
   details of the object representation can lead to code execution
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">
    vulnerabilities
   </a>
   .
  </p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      OOP57-CPP
     </td>
     <td>
      High
     </td>
     <td>
      Probable
     </td>
     <td>
      High
     </td>
     <td>
      <strong>
       P6
      </strong>
     </td>
     <td>
      <strong>
       L2
      </strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astrée
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>
       stdlib-use-ato
       stdlib-use
       stdlib-use-getenv
       stdlib-use-system
       include-time
       stdlib-use-string-unbounded
      </strong>
     </td>
     <td>
      Partially checked
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       C++5017, C++5038
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong>
       <a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">
        CERT.OOP.CSTD_FUNC_USE
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>
       44 S
      </strong>
     </td>
     <td>
      Enhanced Enforcement
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>
       CERT_CPP-OOP57-a
      </strong>
      <strong>
       CERT_CPP-OOP57-b
      </strong>
     </td>
     <td>
      Do not initialize objects with a non-trivial class type using C standard library functions
      Do not compare objects of nonstandard-layout class type with C standard library functions
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcoop57cpp.html">
       CERT C++: OOP57-CPP
      </a>
     </td>
     <td>
      Checks for bytewise operations on nontrivial class object (rule fully covered)
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>
       5017, 5038
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">
       PVS-Studio
      </a>
     </td>
     <td>
      7.16
     </td>
     <td>
      <strong>
       V598
       <a href="https://pvs-studio.com/en/docs/warnings/v598/">
       </a>
      </strong>
      ,
      <strong>
       <a href="https://pvs-studio.com/en/docs/warnings/v780/">
        V780
       </a>
      </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/RuleChecker">
       RuleChecker
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>
       <strong>
        stdlib-use-ato
        stdlib-use
        stdlib-use-getenv
        stdlib-use-system
        include-time
        stdlib-use-string-unbounded
       </strong>
      </strong>
     </td>
     <td>
      Partially checked
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>
   Search for
   <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabil">
    vulnerabilities
   </a>
   resulting from the violation of this rule on the
   <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;amp;query=FIELD+KEYWORDS+contains+OOP57-CPP">
    CERT website
   </a>
   .
  </p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP62-CPP.+Do+not+access+the+bits+of+an+object+representation+that+are+not+part+of+the+object%27s+value+representation">
       EXP62-CPP. Do not access the bits of an object representation that are not part of the object's value representation
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 3.9, "Types"
      Subclause 3.10, "Lvalues and Rvalues"
      Clause 9, "Classes"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>