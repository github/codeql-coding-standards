<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>Copy operations (copy constructors and copy assignment operators) are expected to copy the salient properties of a source object into the destination object, with the resulting object being a "copy" of the original. What is considered to be a salient property of the type is type-dependent, but for types that expose comparison or equality operators, includes any properties used for those comparison operations. This expectation leads to assumptions in code that a copy operation results in a destination object with a value representation that is equivalent to the source object value representation. Violation of this basic assumption can lead to unexpected behavior.</p>
  <p>Ideally, the copy operator should have an idiomatic signature. For copy constructors, that is <code>T(const T&amp;);</code> and for copy assignment operators, that is <code>T&amp; operator=(const T&amp;);</code>. Copy constructors and copy assignment operators that do not use an idiomatic signature do not meet the requirements of the <code>CopyConstructible</code> or <code>CopyAssignable</code> concept, respectively. This precludes the type from being used with common standard library functionality [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>].</p>
  <p>When implementing a copy operator, do not mutate any externally observable members of the source object operand or globally accessible information. Externally observable members include, but are not limited to, members that participate in comparison or equality operations, members whose values are exposed via public APIs, and global variables.</p>
  <p>Before C++11, a copy operation that mutated the source operand was the only way to provide move-like semantics. However, the language did not provide a way to enforce that this operation only occurred when the source operand was at the end of its lifetime, which led to fragile APIs like <code>std::auto_ptr</code>. In C++11 and later, such a situation is a good candidate for a move operation instead of a copy operation.</p>
  <p><strong>auto_ptr</strong></p>
  <p>For example, in C++03, <code>std::auto_ptr</code> had the following copy operation signatures [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2003">ISO/IEC 14882-2003</a>]:</p>
  <table>
   <tbody>
    <tr>
     <td>
      Copy constructor
     </td>
     <td>
      <code>auto_ptr(auto_ptr &amp;A);</code>
     </td>
    </tr>
    <tr>
     <td>
      Copy assignment
     </td>
     <td>
      <code>auto_ptr&amp; operator=(auto_ptr &amp;A);</code>
     </td>
    </tr>
   </tbody>
  </table>
  <p>Both copy construction and copy assignment would mutate the source argument, <code>A</code>, by effectively calling <code>this-&gt;reset(A.release())</code>. However, this invalidated assumptions made by standard library algorithms such as <code>std::sort()</code>, which may need to make a copy of an object for later comparisons [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Hinnant05">Hinnant 05</a>]. Consider the following implementation of <code>std::sort()</code> that implements the <a href="https://en.wikipedia.org/wiki/Quicksort">quick sort</a> algorithm.</p>
  <sample language="cpp">// ...
value_type pivot_element = *mid_point;
// ...</sample>
  <p>At this point, the sorting algorithm assumes that <code>pivot_element</code> and <code>*mid_point</code> have equivalent value representations and will compare equal. However, for <code>std::auto_ptr</code>, this is not the case because <code>*mid_point</code> has been mutated and results in unexpected behavior.</p>
  <p>In C++11, the <code>std::unique_ptr</code> smart pointer class was introduced as a replacement for <code>std::auto_ptr</code> to better specify the ownership semantics of pointer objects. Rather than mutate the source argument in a copy operation, <code>std::unique_ptr</code> explicitly deletes the copy constructor and copy assignment operator, and instead uses a move constructor and move assignment operator. Subsequently, <code>std::auto_ptr</code> was deprecated in C++11.</p>
  <p>Noncompliant Code Example</p>
  <p>In this noncompliant code example, the copy operations for <code>A</code> mutate the source operand by resetting its member variable <code>m</code> to <code>0</code>. When <code>std::fill()</code> is called, the first element copied will have the original value of <code>obj.m</code>, <code>12</code>, at which point <code>obj.m</code> is set to <code>0</code>. The subsequent nine copies will all retain the value <code>0</code>.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class A {
  mutable int m;
  
public:
  A() : m(0) {}
  explicit A(int m) : m(m) {}
  
  A(const A &amp;other) : m(other.m) {
    other.m = 0;
  }
  
  A&amp; operator=(const A &amp;other) {
    if (&amp;other != this) {
      m = other.m;
      other.m = 0;
    }
    return *this;
  }
  
  int get_m() const { return m; }
};

void f() {
  std::vector&lt;A&gt; v{10};
  A obj(12);
  std::fill(v.begin(), v.end(), obj);
}</sample>
 </section>
 <section title="Compliant Solution">
  <p>In this compliant solution, the copy operations for <code>A</code> no longer mutate the source operand, ensuring that the vector contains equivalent copies of <code>obj</code>. Instead, <code>A</code> has been given move operations that perform the mutation when it is safe to do so.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class A {
  int m;
  
public:
  A() : m(0) {}
  explicit A(int m) : m(m) {}
  
  A(const A &amp;other) : m(other.m) {}
  A(A &amp;&amp;other) : m(other.m) { other.m = 0; }
  
  A&amp; operator=(const A &amp;other) {
    if (&amp;other != this) {
      m = other.m;
    }
    return *this;
  }
 
  A&amp; operator=(A &amp;&amp;other) {
    m = other.m;
    other.m = 0;
    return *this;
  }
  
  int get_m() const { return m; }
};

void f() {
  std::vector&lt;A&gt; v{10};
  A obj(12);
  std::fill(v.begin(), v.end(), obj);
}</sample>
 </section>
 <section title="Exceptions">
  <p><strong>OOP58-CPP-EX0:</strong> Reference counting, and implementations such as <code>std::shared_ptr&lt;&gt;</code> constitute an exception to this rule. Any copy or assignment operation of a reference-counted object requires the reference count to be incremented. The semantics of reference counting are well-understood, and it can be argued that the reference count is not a salient part of the <code>shared_pointer</code> object.</p>
 </section>
 <section title="Risk Assessment">
  <p>Copy operations that mutate the source operand or global state can lead to unexpected program behavior. Using such a type in a Standard Template Library container or algorithm can also lead to undefined behavior.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      OOP58-CPP
     </td>
     <td>
      Low
     </td>
     <td>
      Likely
     </td>
     <td>
      Low
     </td>
     <td>
      <strong>P9</strong>
     </td>
     <td>
      <strong>L2</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++4075</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">CERT.OOP.COPY_MUTATES </a></strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-OOP58-a</strong>
     </td>
     <td>
      Copy operations must not mutate the source object
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcoop58cpp.html">
       CERT C++: OOP58-CPP
      </a>
     </td>
     <td>
      Checks for copy operation modifying source operand (rule partially covered)
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=142409849">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>4075</strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vuln">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+OOP58-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP54-CPP.+Gracefully+handle+self-copy+assignment">
       OOP54-CPP. Gracefully handle self-copy assignment
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 12.8, "Copying and Moving Class Objects"
      Table 21, "CopyConstructible Requirements"
      Table 23, "CopyAssignable Requirements"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2003">
       ISO/IEC 14882-2003
      </a>
      ]
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Hinnant05">
       Hinnant 2005
      </a>
      ]
     </td>
     <td>
      "Rvalue Reference Recommendations for Chapter 20"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>