<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>Mutex objects are used to protect shared data from being concurrently accessed. If a mutex object is destroyed while a thread is blocked waiting for the lock, <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-criticalsections">critical sections</a> and shared data are no longer protected.</p>
  <p>The C++ Standard, [thread.mutex.class], paragraph 5 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], states the following:</p>
  <blockquote>
   <p>The behavior of a program is undefined if it destroys a <code>mutex</code> object owned by any thread or a thread terminates while owning a <code>mutex</code> object.</p>
  </blockquote>
  <p>Similar wording exists for <code>std::recursive_mutex</code>, <code>std::timed_mutex</code>, <code>std::recursive_timed_mutex</code>, and <code>std::shared_timed_mutex</code>. These statements imply that destroying a mutex object while a thread is waiting on it is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
 </section>
 <section title="Noncompliant Code Example">
  <p>This noncompliant code example creates several threads that each invoke the <code>do_work()</code> function, passing a unique number as an ID.</p>
  <p>Unfortunately, this code contains a race condition, allowing the mutex to be destroyed while it is still owned, because <code>start_threads()</code> may invoke the mutex's destructor before all of the threads have exited.</p>
  <sample language="cpp">#include &lt;mutex&gt;
#include &lt;thread&gt;

const size_t maxThreads = 10;

void do_work(size_t i, std::mutex *pm) {
  std::lock_guard&lt;std::mutex&gt; lk(*pm);

  // Access data protected by the lock.
}

void start_threads() {
  std::thread threads[maxThreads];
  std::mutex m;

  for (size_t i = 0; i &lt; maxThreads; ++i) {
    threads[i] = std::thread(do_work, i, &amp;m);
  }
}
</sample>
 </section>
 <section title="Compliant Solution">
  <p>This compliant solution eliminates the race condition by extending the lifetime of the mutex.</p>
  <sample language="cpp">#include &lt;mutex&gt;
#include &lt;thread&gt;

const size_t maxThreads = 10;

void do_work(size_t i, std::mutex *pm) {
  std::lock_guard&lt;std::mutex&gt; lk(*pm);

  // Access data protected by the lock.
}

std::mutex m;

void start_threads() {
  std::thread threads[maxThreads];

  for (size_t i = 0; i &lt; maxThreads; ++i) {
    threads[i] = std::thread(do_work, i, &amp;m);
  }
}
</sample>
 </section>
 <section title="Compliant Solution">
  <p>This compliant solution eliminates the race condition by joining the threads before the mutex's destructor is invoked.</p>
  <sample language="cpp">#include &lt;mutex&gt;
#include &lt;thread&gt;

const size_t maxThreads = 10;

void do_work(size_t i, std::mutex *pm) {
  std::lock_guard&lt;std::mutex&gt; lk(*pm);

  // Access data protected by the lock.
}
void run_threads() {
  std::thread threads[maxThreads];
  std::mutex m;

  for (size_t i = 0; i &lt; maxThreads; ++i) {
    threads[i] = std::thread(do_work, i, &amp;m);
  }

  for (size_t i = 0; i &lt; maxThreads; ++i) {
    threads[i].join();
  }
}</sample>
 </section>
 <section title="Risk Assessment">
  <p>Destroying a mutex while it is locked may result in invalid control flow and data corruption.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      CON50-CPP
     </td>
     <td>
      Medium
     </td>
     <td>
      Probable
     </td>
     <td>
      High
     </td>
     <td>
      <strong>P4</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++4961, C++4962</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">CERT.CONC.MUTEX.DESTROY_WHILE_LOCKED</a></strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-CON50-a</strong>
     </td>
     <td>
      Do not destroy another thread's mutex
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certccon50cpp.html">
       CERT C++: CON50-CPP
      </a>
     </td>
     <td>
      Checks for destruction of locked mutex (rule partially covered)
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=142409849">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>4961, 4962</strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CON50-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="http://cwe.mitre.org/">
       MITRE CWE
      </a>
     </td>
     <td>
      <a href="http://cwe.mitre.org/data/definitions/667.html">
       CWE-667
      </a>
      , Improper Locking
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard">
       SEI CERT C Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/CON31-C.+Do+not+destroy+a+mutex+while+it+is+locked">
       CON31-C. Do not destroy a mutex while it is locked
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 30.4.1, "Mutex Requirements"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>