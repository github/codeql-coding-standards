<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>The C++ Standard Library supplies both recursive and non-recursive mutex classes used to protect <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-criticalsections">critical sections</a>. The recursive mutex classes (<code>std::recursive_mutex</code> and <code>std::recursive_timed_mutex</code>) differ from the non-recursive mutex classes (<code>std::mutex</code>, <code>std::timed_mutex</code>, and <code>std::shared_timed_mutex</code>) in that a recursive mutex may be locked recursively by the thread that currently owns the mutex. All mutex classes support the ability to speculatively lock the mutex through functions such as <code>try_lock()</code>, <code>try_lock_for()</code>, <code>try_lock_until()</code>, <code>try_lock_shared_for()</code>, and <code>try_lock_shared_until()</code>. These speculative locking functions attempt to obtain ownership of the mutex for the calling thread, but will not block in the event the ownership cannot be obtained. Instead, they return a Boolean value specifying whether the ownership of the mutex was obtained or not.</p>
  <p>The C++ Standard, [thread.mutex.requirements.mutex], paragraphs 14 and 15 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], state the following:</p>
  <blockquote>
   <p>The expression <code>m.try_lock()</code> shall be well-formed and have the following semantics:Requires: If <code>m</code> is of type <code>std::mutex</code>, <code>std::timed_mutex</code>, or <code>std::shared_timed_mutex</code>, the calling thread does not own the mutex.</p>
  </blockquote>
  <p>Further, [thread.timedmutex.class], paragraph 3, in part, states the following:</p>
  <blockquote>
   <p>The behavior of a program is undefined if:— a thread that owns a <code>timed_mutex</code> object calls <code>lock()</code>, <code>try_lock()</code>, <code>try_lock_for()</code>, or <code>try_lock_until()</code> on that object</p>
  </blockquote>
  <p>Finally, [thread.sharedtimedmutex.class], paragraph 3, in part, states the following:</p>
  <blockquote>
   <p>The behavior of a program is undefined if:— a thread attempts to recursively gain any ownership of a <code>shared_timed_mutex</code>.</p>
  </blockquote>
  <p>Thus, attempting to speculatively lock a non-recursive mutex object that is already owned by the calling thread is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>. Do not call <code>try_lock()</code>, <code>try_lock_for()</code>, <code>try_lock_until()</code>, <code>try_lock_shared_for()</code>, or <code>try_lock_shared_until()</code> on a non-recursive mutex object from a thread that already owns that mutex object.</p>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, the mutex <code>m</code> is locked by the thread's initial entry point and is speculatively locked in the <code>do_work()</code> function from the same thread, resulting in undefined behavior because it is not a recursive mutex. With common implementations, this may result in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-deadlock">deadlock</a>.</p>
  <sample language="cpp">#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex m;

void do_thread_safe_work();

void do_work() {
  while (!m.try_lock()) {
    // The lock is not owned yet, do other work while waiting.
    do_thread_safe_work();
  }
  try {

    // The mutex is now locked; perform work on shared resources.
    // ...

  // Release the mutex.
  catch (...) {
    m.unlock();
    throw;
  }
  m.unlock();
}

void start_func() {
  std::lock_guard&lt;std::mutex&gt; lock(m);
  do_work();
}

int main() {
  std::thread t(start_func);

  do_work();

  t.join();
}
</sample>
 </section>
 <section title="Compliant Solution">
  <p>This compliant solution removes the lock from the thread's initial entry point, allowing the mutex to be speculatively locked, but not recursively.</p>
  <sample language="cpp">#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex m;

void do_thread_safe_work();

void do_work() {
  while (!m.try_lock()) {
    // The lock is not owned yet, do other work while waiting.
    do_thread_safe_work();
  }
  try {
    // The mutex is now locked; perform work on shared resources.
    // ...

  // Release the mutex.
  catch (...) {
    m.unlock();
    throw;
  }
  m.unlock();
}

void start_func() {
  do_work();
}

int main() {
  std::thread t(start_func);

  do_work();

  t.join();
}</sample>
 </section>
 <section title="Risk Assessment">
  <p>Speculatively locking a non-recursive mutex in a recursive manner is undefined behavior that can lead to deadlock.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      CON56-CPP
     </td>
     <td>
      Low
     </td>
     <td>
      Unlikely
     </td>
     <td>
      High
     </td>
     <td>
      <strong>P1</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++4986, C++4987</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-CON56-a</strong>
     </td>
     <td>
      Avoid double locking
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CON56-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="http://cwe.mitre.org/">
       MITRE CWE
      </a>
     </td>
     <td>
      <a href="http://cwe.mitre.org/data/definitions/667.html">
       CWE-667
      </a>
      , Improper Locking
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 30.4.1, "Mutex Requirements"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>