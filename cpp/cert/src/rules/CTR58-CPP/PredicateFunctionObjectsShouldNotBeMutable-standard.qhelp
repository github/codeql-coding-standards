<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>The C++ standard library implements numerous common algorithms that accept a predicate function object. The C++ Standard, [algorithms.general], paragraph 10 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], states the following:</p>
  <blockquote>
   <p>[<em>Note:</em> Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function objects freely. Programmers for whom object identity is important should consider using a wrapper class that points to a noncopied implementation object such as <code>reference_wrapper&lt;T&gt;</code>, or some equivalent solution. â€” <em>end note</em>]</p>
  </blockquote>
  <p>Because it is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-implementation-definedbehavior">implementation-defined</a> whether an algorithm copies a predicate function object, any such object must either</p>
  <ul>
   <li>implement a function call operator that does not mutate state related to the function object's identity, such as nonstatic data members or captured values, or</li>
   <li>wrap the predicate function object in a <code>std::reference_wrapper&lt;T&gt;</code> (or an equivalent solution).</li>
  </ul>
  <p>Marking the function call operator as <code>const</code> is beneficial, but insufficient, because data members with the <code>mutable</code> storage class specifier may still be modified within a <code>const</code> member function.</p>
 </section>
 <section title="Noncompliant Code Example (Functor)">
  <p>This noncompliant code example attempts to remove the third item in a container using a predicate that returns <code>true</code> only on its third invocation.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
  
class MutablePredicate : public std::unary_function&lt;int, bool&gt; {
  size_t timesCalled;
public:
  MutablePredicate() : timesCalled(0) {}

  bool operator()(const int &amp;) {
    return ++timesCalled == 3;
  }
};
 
template &lt;typename Iter&gt;
void print_container(Iter b, Iter e) {
  std::cout &lt;&lt; "Contains: ";
  std::copy(b, e, std::ostream_iterator&lt;decltype(*b)&gt;(std::cout, " "));
  std::cout &lt;&lt; std::endl;
}
 
void f() {
  std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  print_container(v.begin(), v.end());

  v.erase(std::remove_if(v.begin(), v.end(), MutablePredicate()), v.end());
  print_container(v.begin(), v.end());
}
</sample>
  <p>However, <code>std::remove_if()</code> is permitted to construct and use extra copies of its predicate function. Any such extra copies may result in unexpected output.</p>
  <p><strong>Implementation Details</strong></p>
  <p>This program produces the following results using <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-gcc">gcc</a> 4.8.1 with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-libstdcxx">libstdc++</a>.</p>
  <sample language="cpp">Contains: 0 1 2 3 4 5 6 7 8 9  
Contains: 0 1 3 4 6 7 8 9</sample>
  <p>This result arises because <code>std::remove_if</code> makes two copies of the predicate before invoking it. The first copy is used to determine the location of the first element in the sequence for which the predicate returns <code>true</code>. The subsequent copy is used for removing other elements in the sequence. This results in the third element (<code>2</code>) and sixth element (<code>5</code>) being removed; two distinct predicate functions are used.</p>
 </section>
 <section title="Noncompliant Code Example (Lambda)">
  <p>Similar to the functor noncompliant code example, this noncompliant code example attempts to remove the third item in a container using a predicate lambda function that returns <code>true</code> only on its third invocation. As with the functor, this lambda carries local state information, which it attempts to mutate within its function call operator.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
  
template &lt;typename Iter&gt;
void print_container(Iter b, Iter e) {
  std::cout &lt;&lt; "Contains: ";
  std::copy(b, e, std::ostream_iterator&lt;decltype(*b)&gt;(std::cout, " "));
  std::cout &lt;&lt; std::endl;
}
 
void f() {
  std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  print_container(v.begin(), v.end());

  int timesCalled = 0;
  v.erase(std::remove_if(v.begin(), v.end(), [timesCalled](const int &amp;) mutable { return ++timesCalled == 3; }), v.end());
  print_container(v.begin(), v.end());
}</sample>
 </section>
 <section title="Compliant Solution (std::reference_wrapper)">
  <p>This compliant solution uses <code>std::ref</code> to wrap the predicate in a <code>std::reference_wrapper&lt;T&gt;</code> object, ensuring that copies of the wrapper object all refer to the same underlying predicate object.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
  
class MutablePredicate : public std::unary_function&lt;int, bool&gt; {
  size_t timesCalled;
public:
  MutablePredicate() : timesCalled(0) {}

  bool operator()(const int &amp;) {
    return ++timesCalled == 3;
  }
};
 
template &lt;typename Iter&gt;
void print_container(Iter b, Iter e) {
  std::cout &lt;&lt; "Contains: ";
  std::copy(b, e, std::ostream_iterator&lt;decltype(*b)&gt;(std::cout, " "));
  std::cout &lt;&lt; std::endl;
}
 
void f() {
  std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  print_container(v.begin(), v.end());

  MutablePredicate mp;
  v.erase(std::remove_if(v.begin(), v.end(), std::ref(mp)), v.end());
  print_container(v.begin(), v.end());
}</sample>
  <p>The above compliant solution demonstrates using a reference wrapper over a functor object but can similarly be used with a stateful lambda. The code produces the expected results, where only the third element is removed.</p>
  <sample language="cpp">Contains: 0 1 2 3 4 5 6 7 8 9  
Contains: 0 1 3 4 5 6 7 8 9</sample>
 </section>
 <section title="Compliant Solution (Iterator Arithmetic)">
  <p>Removing a specific element of a container does not require a predicate function but can instead simply use <code>std::vector::erase()</code>, as in this compliant solution.</p>
  <sample language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
 
template &lt;typename Iter&gt;
void print_container(Iter B, Iter E) {
  std::cout &lt;&lt; "Contains: ";
  std::copy(B, E, std::ostream_iterator&lt;decltype(*B)&gt;(std::cout, " "));
  std::cout &lt;&lt; std::endl;
}
 
void f() {
  std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  print_container(v.begin(), v.end());
  v.erase(v.begin() + 3);
  print_container(v.begin(), v.end());
}</sample>
 </section>
 <section title="Risk Assessment">
  <p>Using a predicate function object that contains state can produce unexpected values.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      CTR58-CPP
     </td>
     <td>
      Low
     </td>
     <td>
      Likely
     </td>
     <td>
      High
     </td>
     <td>
      <strong> P3 </strong>
     </td>
     <td>
      <strong> L3 </strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++3225, C++3226, C++3227, C++3228, C++3229, C++3230, C++3231, C++3232, C++3233, C++3234</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-CTR58-a</strong>
     </td>
     <td>
      Make predicates const pure functions
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>3225, 3226, 3227, 3228, 3229, </strong>
      <strong>3230, 3231, 3232, 3233, 3234 </strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR44-CPP">CERT website</a>.</p>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 25.1, "General"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers01">
       Meyers 2001
      </a>
      ]
     </td>
     <td>
      Item 39, "Make Predicates Pure Functions"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>