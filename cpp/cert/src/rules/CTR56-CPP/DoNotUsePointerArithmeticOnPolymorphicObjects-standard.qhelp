<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>The definition of <em>pointer arithmetic</em> from the C++ Standard, [expr.add], paragraph 7 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], states the following:</p>
  <blockquote>
   <p>For addition or subtraction, if the expressions <code>P</code> or <code>Q</code> have type “pointer to <em>cv</em> <code>T</code>”, where <code>T</code> is different from the cv-unqualified array element type, the behavior is undefined. [<em>Note:</em> In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type. —<em>end note</em>]</p>
  </blockquote>
  <p>Pointer arithmetic does not account for polymorphic object sizes, and attempting to perform pointer arithmetic on a polymorphic object value results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
  <p>The C++ Standard, [expr.sub], paragraph 1 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], defines array subscripting as being identical to pointer arithmetic. Specifically, it states the following:</p>
  <blockquote>
   <p>The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>.</p>
  </blockquote>
  <p>Do not use pointer arithmetic, including array subscripting, on polymorphic objects.</p>
  <p>The following code examples assume the following static variables and class definitions.</p>
  <sample language="cpp">int globI;
double globD;

struct S {
  int i;
  
  S() : i(globI++) {}
};

struct T : S {
  double d;
  
  T() : S(), d(globD++) {}
};</sample>
 </section>
 <section title="Noncompliant Code Example (Pointer Arithmetic)">
  <p>In this noncompliant code example, <code>f()</code> accepts an array of <code>S</code> objects as its first parameter. However, <code>main()</code> passes an array of <code>T</code> objects as the first argument to <code>f()</code>, which results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> due to the pointer arithmetic used within the <code>for</code> loop.</p>
  <sample language="cpp">#include &lt;iostream&gt;
 
// ... definitions for S, T, globI, globD ...

void f(const S *someSes, std::size_t count) { 
  for (const S *end = someSes + count; someSes != end; ++someSes) {
    std::cout &lt;&lt; someSes-&gt;i &lt;&lt; std::endl;
  }
}

int main() {
  T test[5];
  f(test, 5);
}
</sample>
 </section>
 <section title="Noncompliant Code Example (Array Subscripting)">
  <p>In this noncompliant code example, the <code>for</code> loop uses array subscripting. Since array subscripts are computed using pointer arithmetic, this code also results in undefined behavior.</p>
  <sample language="cpp">#include &lt;iostream&gt;
 
// ... definitions for S, T, globI, globD ...

void f(const S *someSes, std::size_t count) { 
  for (std::size_t i = 0; i &lt; count; ++i) {
    std::cout &lt;&lt; someSes[i].i &lt;&lt; std::endl;
  }
}

int main() {
  T test[5];
  f(test, 5);
}</sample>
 </section>
 <section title="Compliant Solution (Array)">
  <p>Instead of having an array of objects, an array of pointers solves the problem of the objects being of different sizes, as in this compliant solution.</p>
  <sample language="cpp">#include &lt;iostream&gt;

// ... definitions for S, T, globI, globD ...

void f(const S * const *someSes, std::size_t count) { 
  for (const S * const *end = someSes + count; someSes != end; ++someSes) {
    std::cout &lt;&lt; (*someSes)-&gt;i &lt;&lt; std::endl;
  }
}

int main() {
  S *test[] = {new T, new T, new T, new T, new T};
  f(test, 5);
  for (auto v : test) {
    delete v;
  }
}
</sample>
  <p>The elements in the arrays are no longer polymorphic objects (instead, they are pointers to polymorphic objects), and so there is no <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> with the pointer arithmetic.</p>
 </section>
 <section title="Compliant Solution (std::vector)">
  <p>Another approach is to use a standard template library (STL) container instead of an array and have <code>f()</code> accept iterators as parameters, as in this compliant solution. However, because STL containers require homogeneous elements, pointers are still required within the container.</p>
  <sample language="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

// ... definitions for S, T, globI, globD ...
template &lt;typename Iter&gt;
void f(Iter i, Iter e) {
  for (; i != e; ++i) {
    std::cout &lt;&lt; (*i)-&gt;i &lt;&lt; std::endl;
  }
}

int main() {
  std::vector&lt;S *&gt; test{new T, new T, new T, new T, new T};
  f(test.cbegin(), test.cend());
  for (auto v : test) {
    delete v;
  }
}
</sample>
 </section>
 <section title="Risk Assessment">
  <p>Using arrays polymorphically can result in memory corruption, which could lead to an attacker being able to execute arbitrary code.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      CTR56-CPP
     </td>
     <td>
      High
     </td>
     <td>
      Likely
     </td>
     <td>
      High
     </td>
     <td>
      <strong>P9</strong>
     </td>
     <td>
      <strong>L2</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">
       Axivion Bauhaus Suite
      </a>
     </td>
     <td>
      7.2.0
     </td>
     <td>
      <strong>CertC++-CTR56</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++3073</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-CTR56-a</strong>
      <strong>CERT_CPP-CTR56-b</strong>
      <strong>CERT_CPP-CTR56-c</strong>
     </td>
     <td>
      Don't treat arrays polymorphically
      A pointer to an array of derived class objects should not be converted to a base class pointer
      Do not treat arrays polymorphically
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>567 S</strong>
     </td>
     <td>
      Enhanced Enforcement
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong>3073</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">
       PVS-Studio
      </a>
     </td>
     <td>
      7.17
     </td>
     <td>
      <strong><a href="https://pvs-studio.com/en/docs/warnings/v777/">V777</a></strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabil">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+CTR39-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">
       SEI CERT C Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/c/ARR39-C.+Do+not+add+or+subtract+a+scaled+integer+to+a+pointer">
       ARR39-C. Do not add or subtract a scaled integer to a pointer
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 5.7, "Additive Operators"
      Subclause 5.2.1, "Subscripting"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-LockheedMartin05">
       Lockheed Martin 2005
      </a>
      ]
     </td>
     <td>
      AV Rule 96, "Arrays shall not be treated polymorphically"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers96">
       Meyers 1996
      </a>
      ]
     </td>
     <td>
      Item 3, "Never Treat Arrays Polymorphically"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Stroustrup06">
       Stroustrup 2006
      </a>
      ]
     </td>
     <td>
      "What's Wrong with Arrays?"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter04">
       Sutter 2004
      </a>
      ]
     </td>
     <td>
      Item 100, "Don't Treat Arrays Polymorphically"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>