<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>Referring to objects of incomplete class type, also known as <em>forward declarations</em>, is a common practice. One such common usage is with the "pimpl idiom" [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter00">Sutter 00</a>] whereby an opaque pointer is used to hide implementation details from a public-facing API. However, attempting to delete a pointer to an object of incomplete class type can lead to <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>. The C++ Standard, [expr.delete], paragraph 5 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], states the following:</p>
  <blockquote>
   <p>If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>
  </blockquote>
  <p>Do not attempt to delete a pointer to an object of <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-incompletetype">incomplete type</a>. Although it is well-formed if the class has no nontrivial destructor and no associated deallocation function, it would become undefined behavior were a nontrivial destructor or deallocation function added later. It would be possible to check for a nontrivial destructor at compile time using a <code>static_assert</code> and the <code>std::is_trivially_destructible</code> type trait, but no such type trait exists to test for the presence of a deallocation function.</p>
  <p>Pointer downcasting to a pointer of incomplete class type has similar caveats. Pointer upcasting (casting from a more derived type to a less derived type) is a standard implicit conversion operation. C++ allows <code>static_cast</code> to perform the inverse operation, pointer downcasting, via [expr.static.cast], paragraph 7. However, when the pointed-to type is incomplete, the compiler is unable to make any class offset adjustments that may be required in the presence of multiple inheritance, resulting in a pointer that cannot be validly dereferenced.</p>
  <p><code>reinterpret_cast</code> of a pointer type is defined by [expr.reinterpret.cast], paragraph 7, as being <code>static_cast&lt;cv T *&gt;(static_cast&lt;cv void *&gt;(PtrValue))</code>, meaning that <code>reinterpret_cast</code> is simply a sequence of <code>static_cast</code> operations. C-style casts of a pointer to an incomplete object type are defined as using either <code>static_cast</code> or <code>reinterpret_cast</code> (it is unspecified which is picked) in [expr.cast], paragraph 5.</p>
  <p>Do not attempt to cast through a pointer to an object of incomplete type. The cast operation itself is well-formed, but dereferencing the resulting pointer may result in undefined behavior if the downcast is unable to adjust for multiple inheritance.</p>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, a class attempts to implement the pimpl idiom but deletes a pointer to an incomplete class type, resulting in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> if <code>Body</code> has a nontrivial destructor.</p>
  <sample language="cpp">class Handle {
  class Body *impl;  // Declaration of a pointer to an incomplete class
public:
  ~Handle() { delete impl; } // Deletion of pointer to an incomplete class
  // ...
};
</sample>
 </section>
 <section title="Compliant Solution (delete)">
  <p>In this compliant solution, the deletion of <code>impl</code> is moved to a part of the code where <code>Body</code> is defined.</p>
  <sample language="cpp">class Handle {
  class Body *impl;  // Declaration of a pointer to an incomplete class
public:
  ~Handle();
  // ...
};

// Elsewhere
class Body { /* ... */ };
 
Handle::~Handle() {
  delete impl;
}</sample>
 </section>
 <section title="Compliant Solution (std::shared_ptr)">
  <p>In this compliant solution, a <code>std::shared_ptr</code> is used to own the memory to <code>impl</code>. A <code>std::shared_ptr</code> is capable of referring to an incomplete type, but a <code>std::unique_ptr</code> is not.</p>
  <sample language="cpp">#include &lt;memory&gt;
 
class Handle {
  std::shared_ptr&lt;class Body&gt; impl;
  public:
    Handle();
    ~Handle() {}
    // ...
};</sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>Pointer downcasting (casting a pointer to a base class into a pointer to a derived class) may require adjusting the address of the pointer by a fixed amount that can be determined only when the layout of the class inheritance structure is known. In this noncompliant code example, <code>f()</code> retrieves a polymorphic pointer of complete type <code>B</code> from <code>get_d()</code>. That pointer is then cast to a pointer of incomplete type <code>D</code> before being passed to <code>g()</code>. Casting to a pointer to the derived class may fail to properly adjust the resulting pointer, causing <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> when the pointer is dereferenced by calling <code>d-&gt;do_something()</code>.</p>
  <sample language="cpp">// File1.h
class B {
protected:
  double d;
public:
  B() : d(1.0) {}
};
 
// File2.h
void g(class D *);
class B *get_d(); // Returns a pointer to a D object

// File1.cpp
#include "File1.h"
#include "File2.h"

void f() {
  B *v = get_d();
  g(reinterpret_cast&lt;class D *&gt;(v));
}
 
// File2.cpp
#include "File2.h"
#include "File1.h"
#include &lt;iostream&gt;

class Hah {
protected:
  short s;
public:
  Hah() : s(12) {}
};

class D : public Hah, public B {
  float f;
public:
  D() : Hah(), B(), f(1.2f) {}
  void do_something() { std::cout &lt;&lt; "f: " &lt;&lt; f &lt;&lt; ", d: " &lt;&lt; d &lt;&lt; ", s: " &lt;&lt; s &lt;&lt; std::endl; }
};

void g(D *d) {
  d-&gt;do_something();
}

B *get_d() {
  return new D;
}
</sample>
  <p><strong>Implementation Details</strong></p>
  <p>When compiled with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-clang">Clang</a><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-clang">BB. Definitions#clang</a>3.8 and the function <code>f()</code> is executed, the noncompliant code example prints the following.</p>
  <sample language="cpp">f: 1.89367e-40, d: 5.27183e-315, s: 0</sample>
  <p>Similarly, unexpected values are printed when the example is run in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-msvc">Microsoft Visual Studio</a> 2015 and <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-gcc">GCC </a>6.1.0.</p>
 </section>
 <section title="Compliant Solution">
  <p>This compliant solution assumes that the intent is to hide implementation details by using incomplete class types. Instead of requiring a <code>D *</code> to be passed to <code>g()</code>, it expects a <code>B *</code> type.</p>
  <sample language="cpp">// File1.h -- contents identical.
// File2.h
void g(class B *); // Accepts a B object, expects a D object
class B *get_d(); // Returns a pointer to a D object

// File1.cpp
#include "File1.h"
#include "File2.h"

void f() {
  B *v = get_d();
  g(v);
}
 
// File2.cpp
// ... all contents are identical until ...
void g(B *d) {
  D *t = dynamic_cast&lt;D *&gt;(d);
  if (t) {
    t-&gt;do_something();
  } else {
    // Handle error
  }
}

B *get_d() {
  return new D;
}</sample>
 </section>
 <section title="Risk Assessment">
  <p>Casting pointers or references to incomplete classes can result in bad addresses. Deleting a pointer to an incomplete class results in undefined behavior if the class has a nontrivial destructor. Doing so can cause program termination, a runtime signal, or resource leaks.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      EXP57-CPP
     </td>
     <td>
      Medium
     </td>
     <td>
      Unlikely
     </td>
     <td>
      Medium
     </td>
     <td>
      <strong>P4</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astr√©e
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>delete-with-incomplete-type</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Coverity">
       Coverity
      </a>
     </td>
     <td>
      6.5
     </td>
     <td>
      <strong>DELETE_VOID</strong>
     </td>
     <td>
      Fully implemented
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang">
       Clang
      </a>
     </td>
     <td>
      3.9
     </td>
     <td>
      <code>-Wdelete-incomplete</code>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar">
       CodeSonar
      </a>
     </td>
     <td>
      6.2p0
     </td>
     <td>
      <strong>LANG.CAST.PC.INC</strong>
     </td>
     <td>
      Conversion: pointer to incomplete
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++3112</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong><a href="https://support.roguewave.com/documentation/klocwork/en/current/certcandcsecurecodingstandardidsmappedtoklocworkcandccheckers/">CERT.EXPR.DELETE_PTR.INCOMPLETE_TYPE</a></strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>169 S, 554 S</strong>
      <strong> </strong>
     </td>
     <td>
      Enhanced Enforcement
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-EXP57-a</strong>
      <strong>CERT_CPP-EXP57-b</strong>
     </td>
     <td>
      Do not delete objects with incomplete class at the point of deletion
      Conversions shall not be performed between a pointer to an incomplete type and any other type
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft Insure++
      </a>
     </td>
     <td>
     </td>
     <td>
     </td>
     <td>
      Runtime detection
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcexp57cpp.html">
       CERT C++: EXP57-CPP
      </a>
     </td>
     <td>
      Checks for conversion or deletion of incomplete class pointer
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/RuleChecker">
       RuleChecker
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>delete-with-incomplete-type</strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+EXP39-CPP">CERT website</a>.</p>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Dewhurst02">
       Dewhurst 2002
      </a>
      ]
     </td>
     <td>
      Gotcha #39, "Casting Incomplete Types"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 4.10, "Pointer Conversions"
      Subclause 5.2.9, "Static Cast"
      Subclause 5.2.10, "Reinterpret Cast"
      Subclause 5.3.5, "Delete"
      Subclause 5.4, "Explicit Type Conversion (Cast Notation)"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter00">
       Sutter 2000
      </a>
      ]
     </td>
     <td>
      "Compiler Firewalls and the Pimpl Idiom"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>