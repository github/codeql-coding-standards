<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>Virtual functions allow for the choice of member function calls to be determined at run time based on the dynamic type of the object that the member function is being called on. This convention supports object-oriented programming practices commonly associated with object inheritance and function overriding. When calling a nonvirtual member function or when using a class member access expression to denote a call, the specified function is called. Otherwise, a virtual function call is made to the final overrider in the dynamic type of the object expression.</p>
  <p>However, during the construction and destruction of an object, the rules for virtual method dispatch on that object are restricted. The C++ Standard, [class.cdtor], paragraph 4 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], states the following:</p>
  <blockquote>
   <p>Member functions, including virtual functions, can be called during construction or destruction. When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class’s non-static data members, and the object to which the call applies is the object (call it <code>x</code>) under construction or destruction, the function called is the final overrider in the constructor’s or destructor’s class and not one overriding it in a more-derived class. If the virtual function call uses an explicit class member access and the object expression refers to the complete object of <code>x</code> or one of that object’s base class subobjects but not <code>x</code> or one of its base class subobjects, the behavior is undefined.</p>
  </blockquote>
  <p>Do not directly or indirectly invoke a virtual function from a constructor or destructor that attempts to call into the object under construction or destruction. Because the order of construction starts with base classes and moves to more derived classes, attempting to call a derived class function from a base class under construction is dangerous. The derived class has not had the opportunity to initialize its resources, which is why calling a virtual function from a constructor does not result in a call to a function in a more derived class. Similarly, an object is destroyed in reverse order from construction, so attempting to call a function in a more derived class from a destructor may access resources that have already been released.</p>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, the base class attempts to seize and release an object's resources through calls to virtual functions from the constructor and destructor. However, the <code>B::B()</code> constructor calls <code>B::seize()</code> rather than <code>D::seize()</code>. Likewise, the <code>B::~B()</code> destructor calls <code>B::release()</code> rather than <code>D::release()</code>.</p>
  <sample language="cpp">struct B {
  B() { seize(); }
  virtual ~B() { release(); }
 
protected:
  virtual void seize();
  virtual void release();
};

struct D : B {
  virtual ~D() = default;
 
protected:
  void seize() override {
    B::seize();
    // Get derived resources...
  }
 
  void release() override {
    // Release derived resources...
    B::release();
  }
};
</sample>
  <p>The result of running this code is that no derived class resources will be seized or released during the initialization and destruction of object of type <code>D</code>. At the time of the call to <code>seize()</code> from <code>B::B()</code>, the <code>D</code> constructor has not been entered, and the behavior of the under-construction object will be to invoke <code>B::seize()</code> rather than <code>D::seize()</code>. A similar situation occurs for the call to <code>release()</code> in the base class destructor. If the functions <code>seize()</code> and <code>release()</code> were declared to be pure virtual functions, the result would be <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
 </section>
 <section title="Compliant Solution">
  <p>In this compliant solution, the constructors and destructors call a nonvirtual, private member function (suffixed with <code>mine</code>) instead of calling a virtual function. The result is that each class is responsible for seizing and releasing its own resources.</p>
  <sample language="cpp">class B {
  void seize_mine();
  void release_mine();
  
public:
  B() { seize_mine(); }
  virtual ~B() { release_mine(); }

protected:
  virtual void seize() { seize_mine(); }
  virtual void release() { release_mine(); }
};

class D : public B {
  void seize_mine();
  void release_mine();
  
public:
  D() { seize_mine(); }
  virtual ~D() { release_mine(); }

protected:
  void seize() override {
    B::seize();
    seize_mine();
  }
  
  void release() override {
    release_mine();
    B::release();
  }
};</sample>
 </section>
 <section title="Exceptions">
  <p><strong>OOP50-CPP-EX1:</strong> Because valid use cases exist that involve calling (non-pure) virtual functions from the constructor of a class, it is permissible to call the virtual function with an explicitly qualified ID. The qualified ID signifies to code maintainers that the expected behavior is for the class under construction or destruction to be the final overrider for the function call.</p>
  <sample language="cpp">struct A {
  A() {
    // f();   // WRONG!
    A::f();   // Okay
  }
  virtual void f();
};
</sample>
  <p><strong>OOP50-CPP-EX2:</strong> It is permissible to call a virtual function that has the <code>final</code> <em>virt-specifier</em> from a constructor or destructor, as in this example.</p>
  <sample language="cpp">struct A {
  A();
  virtual void f();
};
 
struct B : A {
  B() : A() {
    f();  // Okay
  }
  void f() override final;
};</sample>
  <p>Similarly, it is permissible to call a virtual function from a constructor or destructor of a class that has the <code>final</code> <em>class-virt-specifier</em>, as in this example.</p>
  <sample language="cpp">struct A {
  A();
  virtual void f();
};
 
struct B final : A {
  B() : A() {
    f();  // Okay
  }
  void f() override;
};</sample>
  <p>In either case, <code>f()</code> must be the final overrider, guaranteeing consistent behavior of the function being called.</p>
 </section>
 <section title="Risk Assessment">
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      OOP50-CPP
     </td>
     <td>
      Low
     </td>
     <td>
      Unlikely
     </td>
     <td>
      Medium
     </td>
     <td>
      <strong>P2</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=222953724">
       Astrée
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>virtual-call-in-constructorinvalid_function_pointer</strong>
     </td>
     <td>
      Fully checked
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">
       Axivion Bauhaus Suite
      </a>
     </td>
     <td>
      7.2.0
     </td>
     <td>
      <strong>CertC++-OOP50</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang">
       Clang
      </a>
     </td>
     <td>
      3.9
     </td>
     <td>
      <code>clang-analyzer-alpha.cplusplus.VirtualCall</code>
     </td>
     <td>
      Checked by
      <code>clang-tidy</code>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar">
       CodeSonar
      </a>
     </td>
     <td>
      6.2p0
     </td>
     <td>
      <strong>LANG.STRUCT.VCALL_IN_CTOR</strong>
      <strong>LANG.STRUCT.VCALL_IN_DTOR</strong>
     </td>
     <td>
      Virtual Call in Constructor
      Virtual Call in Destructor
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++4260, C++4261, C++4273, C++4274, C++4275, C++4276, C++4277, C++4278, C++4279, C++4280, C++4281, C++4282</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>467 S, 92 D</strong>
     </td>
     <td>
      Fully implemented
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-OOP50-a</strong>
      <strong>CERT_CPP-OOP50-b</strong>
      <strong>CERT_CPP-OOP50-c</strong>
      <strong>CERT_CPP-OOP50-d</strong>
     </td>
     <td>
      Avoid calling virtual functions from constructors
      Avoid calling virtual functions from destructors
      Do not invoke class's virtual functions from any of its constructors
      Do not invoke class's virtual functions from its destructor
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcoop50cpp.html">
       CERT C++: OOP50-CPP
      </a>
     </td>
     <td>
      Checks for virtual function call from constructors and destructors (rule fully covered)
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046345">
       PRQA QA-C++
      </a>
     </td>
     <td>
      4.4
     </td>
     <td>
      <strong> 4260, 4261, 4273, 4274,4275, 4276, 4277, 4278,4279, 4280, 4281, 4282 </strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/PVS-Studio">
       PVS-Studio
      </a>
     </td>
     <td>
      7.17
     </td>
     <td>
      <strong><a href="https://pvs-studio.com/en/docs/warnings/v1053/">V1053</a></strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/RuleChecker">
       RuleChecker
      </a>
     </td>
     <td>
      20.10
     </td>
     <td>
      <strong>virtual-call-in-constructor</strong>
     </td>
     <td>
      Fully checked
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046388">
       SonarQube C/C++ Plugin
      </a>
     </td>
     <td>
      4.10
     </td>
     <td>
      <strong><a href="https://www.sonarsource.com/products/codeanalyzers/sonarcfamilyforcpp/rules-cpp.html#RSPEC-1699">S1699</a></strong>
     </td>
     <td>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for other <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerability">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+OOP30-CPP">CERT website</a>.</p>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Dewhurst02">
       Dewhurst 2002
      </a>
      ]
     </td>
     <td>
      Gotcha #75, "Calling Virtual Functions in Constructors and Destructors"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 5.5, "Pointer-to-Member Operators"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-LockheedMartin05">
       Lockheed Martin 2005
      </a>
      ]
     </td>
     <td>
      AV Rule 71.1, "A class's virtual functions shall not be invoked from its destructor or any of its constructors"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Sutter04">
       Sutter 2004
      </a>
      ]
     </td>
     <td>
      Item 49, "Avoid Calling Virtual Functions in Constructors and Destructors"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>