<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>Reclaiming resources when exceptions are thrown is important. An exception being thrown may result in cleanup code being bypassed or an object being left in a partially initialized state. Such a partially initialized object would violate basic exception safety, as described in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR56-CPP.+Guarantee+exception+safety">ERR56-CPP. Guarantee exception safety</a>. It is preferable that resources be reclaimed automatically, using the <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-RAII">RAII</a> design pattern [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Stroustrup01">Stroustrup 2001</a>], when objects go out of scope. This technique avoids the need to write complex cleanup code when allocating resources.</p>
  <p>However, constructors do not offer the same protection. Because a constructor is involved in allocating resources, it does not automatically free any resources it allocates if it terminates prematurely. The C++ Standard, [except.ctor], paragraph 2 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], states the following:</p>
  <blockquote>
   <p>An object of any storage duration whose initialization or destruction is terminated by an exception will have destructors executed for all of its fully constructed subobjects (excluding the variant members of a union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution. Similarly, if the non-delegating constructor for an object has completed execution and a delegating constructor for that object exits with an exception, the objectâ€™s destructor will be invoked. If the object was allocated in a new-expression, the matching deallocation function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</p>
  </blockquote>
  <p>It is generally recommended that constructors that cannot complete their job should throw exceptions rather than exit normally and leave their object in an incomplete state [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Cline09">Cline 2009</a>].</p>
  <p>Resources must not be leaked as a result of throwing an exception, including during the construction of an object.</p>
  <p><em>This rule is a subset of <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM51-CPP.+Properly+deallocate+dynamically+allocated+resources">MEM51-CPP. Properly deallocate dynamically allocated resources</a>, as all failures to deallocate resources violate that rule.</em></p>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, <code>pst</code> is not properly released when <code>process_item</code> throws an exception, causing a resource leak.</p>
  <sample language="cpp">#include &lt;new&gt;
 
struct SomeType {
  SomeType() noexcept; // Performs nontrivial initialization.
  ~SomeType(); // Performs nontrivial finalization.
  void process_item() noexcept(false);
};
 
void f() {
  SomeType *pst = new (std::nothrow) SomeType();
  if (!pst) {
    // Handle error
    return;
  }
 
  try {
    pst-&gt;process_item();
  } catch (...) {
    // Process error, but do not recover from it; rethrow.
    throw;
  }
  delete pst;
}
</sample>
 </section>
 <section title="Compliant Solution (delete)">
  <p>In this compliant solution, the exception handler frees <code>pst</code> by calling <code>delete.</code></p>
  <sample language="cpp">#include &lt;new&gt;

struct SomeType {
  SomeType() noexcept; // Performs nontrivial initialization.
  ~SomeType(); // Performs nontrivial finalization.

  void process_item() noexcept(false);
};

void f() {
  SomeType *pst = new (std::nothrow) SomeType();
  if (!pst) {
    // Handle error
    return;
  }
  try {
    pst-&gt;process_item();
  } catch (...) {
    // Process error, but do not recover from it; rethrow.
    delete pst;
    throw;
  }
  delete pst;
}</sample>
  <p>While this compliant solution properly releases its resources using <code>catch</code> clauses, this approach can have some disadvantages:</p>
  <ul>
   <li>Each distinct cleanup requires its own <code>try</code> and <code>catch</code> blocks.</li>
   <li>The cleanup operation must not throw any exceptions.</li>
  </ul>
 </section>
 <section title="Compliant Solution (RAII Design Pattern)">
  <p>A better approach is to employ RAII. This pattern forces every object to clean up after itself in the face of abnormal behavior, preventing the programmer from having to do so. Another benefit of this approach is that it does not require statements to handle resource allocation errors, in conformance with <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors">MEM52-CPP. Detect and handle memory allocation errors</a>.</p>
  <sample language="cpp">struct SomeType {
  SomeType() noexcept; // Performs nontrivial initialization.
  ~SomeType(); // Performs nontrivial finalization.

  void process_item() noexcept(false);
};

void f() {
  SomeType st;
  try {
    st.process_item();
  } catch (...) {
    // Process error, but do not recover from it; rethrow.
    throw;
  } // After re-throwing the exception, the destructor is run for st.
} // If f() exits without throwing an exception, the destructor is run for st.
</sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, the <code>C::C()</code> constructor might fail to allocate memory for <code>a</code>, might fail to allocate memory for <code>b</code>, or might throw an exception in the <code>init()</code> method. If <code>init()</code> throws an exception, neither <code>a</code> nor <code>b</code> will be released. Likewise, if the allocation for <code>b</code> fails, <code>a</code> will not be released.</p>
  <sample language="cpp">struct A {/* ... */};
struct B {/* ... */};

class C {
  A *a;
  B *b;
protected:
  void init() noexcept(false);
public:
  C() : a(new A()), b(new B()) {
    init();
  }
};
</sample>
 </section>
 <section title="Compliant Solution (try/catch)">
  <p>This compliant solution mitigates the potential failures by releasing <code>a</code> and <code>b</code> if an exception is thrown during their allocation or during <code>init()</code>.</p>
  <sample language="cpp">struct A {/* ... */};
struct B {/* ... */};
 
class C {
  A *a;
  B *b;
protected:
  void init() noexcept(false);
public:
  C() : a(nullptr), b(nullptr) {
    try {
      a = new A();
      b = new B();
      init();
    } catch (...) {
      delete a;
      delete b;
      throw;
    }
  }
};
</sample>
 </section>
 <section title="Compliant Solution (std::unique_ptr)">
  <p>This compliant solution uses <code>std::unique_ptr</code> to create objects that clean up after themselves should anything go wrong in the <code>C::C()</code> constructor. The <code>std::unique_ptr</code> applies the principles of RAII to pointers.</p>
  <sample language="cpp">#include &lt;memory&gt;
 
struct A {/* ... */};
struct B {/* ... */};

class C {
  std::unique_ptr&lt;A&gt; a;
  std::unique_ptr&lt;B&gt; b;
protected:
  void init() noexcept(false);
public:
  C() : a(new A()), b(new B()) {
    init();
  }
};</sample>
 </section>
 <section title="Risk Assessment">
  <p>Memory and other resource leaks will eventually cause a program to crash. If an attacker can provoke repeated resource leaks by forcing an exception to be thrown through the submission of suitably crafted data, then the attacker can mount a <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions">denial-of-service attack</a>.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      ERR57-CPP
     </td>
     <td>
      Low
     </td>
     <td>
      Probable
     </td>
     <td>
      High
     </td>
     <td>
      <strong>P2</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Automated Detection">
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/CodeSonar">
       CodeSonar
      </a>
     </td>
     <td>
      6.2p0
     </td>
     <td>
      <strong>ALLOC.LEAK</strong>
     </td>
     <td>
      Leak
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++4756, C++4757, C++4758</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://www.securecoding.cert.org/confluence/display/cplusplus/Klocwork">
       Klocwork
      </a>
     </td>
     <td>
      2021.4
     </td>
     <td>
      <strong>CL.MLK</strong>
      <strong>MLK.MIGHT</strong>
      <strong>MLK.MUST</strong>
      <strong>MLK.RET.MIGHT</strong>
      <strong>MLK.RET.MUST</strong>
      <strong>RH.LEAK</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/LDRA">
       LDRA tool suite
      </a>
     </td>
     <td>
     </td>
     <td>
      <strong>50 D</strong>
     </td>
     <td>
      Partially implemented
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-ERR57-a</strong>
     </td>
     <td>
      Ensure resources are freed
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcerr57cpp.html">
       CERT C++: ERR57-CPP
      </a>
     </td>
     <td>
      Checks for:
      Resource leak caused by exceptionesource leak caused by exception, object left in partially initialized statebject left in partially initialized state, bad allocation in constructorad allocation in constructor.
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+ERR57-CPP">CERT website</a>.</p>
 </section>
 <section title="Related Guidelines">
  <table>
   <tbody>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682">
       SEI CERT C++ Coding Standard
      </a>
     </td>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors">
       MEM51-CPP. Properly deallocate dynamically allocated resources
      </a>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors">
       MEM52-CPP. Detect and handle memory allocation errors
      </a>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR56-CPP.+Guarantee+exception+safety">
       ERR56-CPP. Guarantee exception safety
      </a>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM52-CPP.+Detect+and+handle+memory+allocation+errors">
      </a>
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Cline09">
       Cline 2009
      </a>
      ]
     </td>
     <td>
      Question 17.2, I'm still not convinced: A 4-line code snippet shows that return-codes aren't any worse than exceptions;
      why should I therefore use exceptions on an application that is orders of magnitude larger?
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 15.2, "Constructors and Destructors"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Meyers96">
       Meyers 1996
      </a>
      ]
     </td>
     <td>
      Item 9, "Use Destructors to Prevent Resource Leaks"
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-Stroustrup01">
       Stroustrup 2001
      </a>
      ]
     </td>
     <td>
      "Exception-Safe Implementation Techniques"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>