<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
 <section title="Description">
  <p>The <code>offsetof()</code> macro is defined by the C Standard as a portable way to determine the offset, expressed in bytes, from the start of the object to a given member of that object. The C Standard, subclause 7.17, paragraph 3 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC9899-1999">ISO/IEC 9899:1999</a>], in part, specifies the following:</p>
  <blockquote>
   <p><code>offsetof(type, member-designator)</code> which expands to an integer constant expression that has type <code>size_t</code>, the value of which is the offset in bytes, to the structure member (designated by <em>member-designator</em>), from the beginning of its structure (designated by <em>type</em>). The type and member designator shall be such that given <code>static type t;</code> then the expression <code>&amp;(t.member-designator)</code> evaluates to an address constant. (If the specified member is a bit-field, the behavior is undefined.)</p>
  </blockquote>
  <p>The C++ Standard, [support.types], paragraph 4 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], places additional restrictions beyond those set by the C Standard:</p>
  <blockquote>
   <p>The macro <code>offsetof(type, member-designator)</code> accepts a restricted set of <em>type</em> arguments in this International Standard. If <em>type</em> is not a <em>standard-layout class</em>, the results are undefined. The expression <code>offsetof(type, member-designator)</code> is never type-dependent and it is value-dependent if and only if <em>type</em> is dependent. The result of applying the <code>offsetof</code> macro to a field that is a static data member or a function member is undefined. No operation invoked by the <code>offsetof</code> macro shall throw an exception and <code>noexcept(offsetof(type, member-designator))</code> shall be true.</p>
  </blockquote>
  <p>When specifying the type argument for the <code>offsetof()</code> macro, pass only a standard-layout class. The full description of a standard-layout class can be found in paragraph 7 of the [class] clause of the C++ Standard, or the type can be checked with the <code>std::is_standard_layout&lt;&gt;</code> type trait. When specifying the member designator argument for the <code>offsetof()</code> macro, do not pass a bit-field, static data member, or function member. Passing an invalid type or member to the <code>offsetof()</code> macro is <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, a type that is not a standard-layout class is passed to the <code>offsetof()</code> macro, resulting in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>.</p>
  <sample language="cpp">#include &lt;cstddef&gt;
 
struct D {
  virtual void f() {}
  int i;
};
 
void f() {
  size_t off = offsetof(D, i);
  // ...
}</sample>
  <p><strong>Implementation Details</strong></p>
  <p>The noncompliant code example does not emit a diagnostic when compiled with the <code>/Wall</code> switch in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-msvc">Microsoft Visual Studio </a>2015 on x86, resulting in <code>off</code> being <code>4</code>, due to the presence of a vtable for type <code>D</code>.</p>
 </section>
 <section title="Compliant Solution">
  <p>It is not possible to determine the offset to <code>i</code> within <code>D</code> because <code>D</code> is not a standard-layout class. However, it is possible to make a standard-layout class within <code>D</code> if this functionality is critical to the application, as demonstrated by this compliant solution.</p>
  <sample language="cpp">#include &lt;cstddef&gt;

struct D {
  virtual void f() {}
  struct InnerStandardLayout {
    int i;
  } inner;
};

void f() {
  size_t off = offsetof(D::InnerStandardLayout, i);
  // ...
}</sample>
 </section>
 <section title="Noncompliant Code Example">
  <p>In this noncompliant code example, the offset to <code>i</code> is calculated so that a value can be stored at that offset within <code>buffer</code>. However, because <code>i</code> is a static data member of the class, this example results in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a>. According to the C++ Standard, [class.static.data], paragraph 1 [<a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">ISO/IEC 14882-2014</a>], static data members are not part of the subobjects of a class.</p>
  <sample language="cpp">#include &lt;cstddef&gt;
 
struct S {
  static int i;
  // ...
};
int S::i = 0;
 
extern void store_in_some_buffer(void *buffer, size_t offset, int val);
extern void *buffer;
 
void f() {
  size_t off = offsetof(S, i);
  store_in_some_buffer(buffer, off, 42);
}</sample>
  <p><strong>Implementation Details</strong></p>
  <p>The noncompliant code example does not emit a diagnostic when compiled with the <code>/Wall</code> switch in Microsoft Visual Studio 2015 on x86, resulting in <code>off</code> being a large value representing the offset between the null pointer address <code>0</code> and the address of the static variable <code>S::i</code>.</p>
 </section>
 <section title="Compliant Solution">
  <p>Because static data members are not a part of the class layout, but are instead an entity of their own, this compliant solution passes the address of the static member variable as the buffer to store the data in and passes <code>0</code> as the offset.</p>
  <sample language="cpp">#include &lt;cstddef&gt;
 
struct S {
  static int i;
  // ...
};
int S::i = 0;
 
extern void store_in_some_buffer(void *buffer, size_t offset, int val);
 
void f() {
  store_in_some_buffer(&amp;S::i, 0, 42);
}</sample>
 </section>
 <section title="Risk Assessment">
  <p>Passing an invalid type or member to <code>offsetof()</code> can result in <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-undefinedbehavior">undefined behavior</a> that might be <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-exploit">exploited</a> to cause data integrity violations or result in incorrect values from the macro expansion.</p>
  <table>
   <tbody>
    <tr>
     <th>
      Rule
     </th>
     <th>
      Severity
     </th>
     <th>
      Likelihood
     </th>
     <th>
      Remediation Cost
     </th>
     <th>
      Priority
     </th>
     <th>
      Level
     </th>
    </tr>
    <tr>
     <td>
      EXP59-CPP
     </td>
     <td>
      Medium
     </td>
     <td>
      Unlikely
     </td>
     <td>
      Medium
     </td>
     <td>
      <strong>P4</strong>
     </td>
     <td>
      <strong>L3</strong>
     </td>
    </tr>
   </tbody>
  </table>
  <p><strong>Automated Detection </strong></p>
  <table>
   <tbody>
    <tr>
     <th>
      Tool
     </th>
     <th>
      Version
     </th>
     <th>
      Checker
     </th>
     <th>
      Description
     </th>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Axivion+Bauhaus+Suite">
       Axivion Bauhaus Suite
      </a>
     </td>
     <td>
      7.2.0
     </td>
     <td>
      <strong>CertC++-EXP59</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Clang">
       Clang
      </a>
     </td>
     <td>
      3.9
     </td>
     <td>
      <code>-Winvalid-offsetof</code>
     </td>
     <td>
      Emits an error diagnostic on invalid member designators, and emits a warning diagnostic on invalid types.
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/GCC">
       GCC
      </a>
     </td>
     <td>
     </td>
     <td>
      <code>-Winvalid-offsetof</code>
     </td>
     <td>
      Emits an error diagnostic on invalid member designators, and emits a warning diagnostic on invalid types.
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Helix+QAC">
       Helix QAC
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>C++3915, C++3916</strong>
     </td>
     <td>
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Parasoft">
       Parasoft C/C++test
      </a>
     </td>
     <td>
      2021.2
     </td>
     <td>
      <strong>CERT_CPP-EXP59-a</strong>
     </td>
     <td>
      Use offsetof() on valid types and members
     </td>
    </tr>
    <tr>
     <td>
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/Polyspace+Bug+Finder">
       Polyspace Bug Finder
      </a>
     </td>
     <td>
      R2021b
     </td>
     <td>
      <a href="https://www.mathworks.com/help/bugfinder/ref/certcexp59cpp.html">
       CERT C++: EXP59-CPP
      </a>
     </td>
     <td>
      Checks use of offsetof macro with nonstandard layout class (rule fully covered)
     </td>
    </tr>
   </tbody>
  </table>
 </section>
 <section title="Related Vulnerabilities">
  <p>Search for <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/BB.+Definitions#BB.Definitions-vulnerabi">vulnerabilities</a> resulting from the violation of this rule on the <a href="https://www.kb.cert.org/vulnotes/bymetric?searchview&amp;query=FIELD+KEYWORDS+contains+EXP59-CPP">CERT website</a>.</p>
 </section>
 <section title="Bibliography">
  <table>
   <tbody>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC9899-1999">
       ISO/IEC 9899:1999
      </a>
      ]
     </td>
     <td>
      Subclause 7.17, "Common Definitions
      <code>&lt;stddef.h&gt;</code>
      "
     </td>
    </tr>
    <tr>
     <td>
      [
      <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/AA.+Bibliography#AA.Bibliography-ISO%2FIEC14882-2014">
       ISO/IEC 14882-2014
      </a>
      ]
     </td>
     <td>
      Subclause 9.4.2, "Static Data Members"
      Subclause 18.2, "Types"
     </td>
    </tr>
   </tbody>
  </table>
 </section>
</qhelp>