/** A module for representing reserved names in C and C++. */

import cpp
import codingstandards.cpp.ReservedNames
import codingstandards.cpp.CKeywords
import codingstandards.cpp.Linkage
import codingstandards.cpp.Macro
import codingstandards.cpp.StandardLibraryNames
import codingstandards.cpp.StdNamespace

module ReservedNames {
  module C11 {
    newtype Scope =
      FileScope() or
      BlockScope() or
      FunctionScope() or
      MacroScope()

    /**
     * A C name space according to C11 6.2.3, not to be confused with a C++ namespace.
     */
    newtype TCNameSpace =
      LabelNameSpace() or
      TagNameSpace() or
      MemberNameSpace() or
      OrdinaryNameSpace() or
      // Create a "fake" name space for macro names
      MacroNameSpace()

    class CNameSpace extends TCNameSpace {
      string toString() {
        this = LabelNameSpace() and result = "label"
        or
        this = TagNameSpace() and result = "tag"
        or
        this = MemberNameSpace() and result = "member"
        or
        this = OrdinaryNameSpace() and result = "ordinary"
        or
        this = MacroNameSpace() and result = "macro"
      }
    }

    private string getDeclDescription(Declaration d) {
      d instanceof Function and result = "Function"
      or
      d instanceof Parameter and result = "Parameter"
      or
      d instanceof LocalVariable and result = "Local variable"
      or
      d instanceof MemberVariable and result = "Member variable"
      or
      d instanceof GlobalVariable and result = "Global variable"
      or
      d instanceof UserType and result = "Type"
      or
      d instanceof EnumConstant and result = "Enum constant"
    }

    /**
     * Whether a C declaration is considered to be at file scope.
     */
    private predicate isFileScope(Declaration d) {
      d.getFile().compiledAsC() and
      // Not inside a block - if the declaration is part of a DeclStmt, it is also part of a function
      // and therefore enclosed in at least one block
      not exists(DeclStmt ds | ds.getADeclaration() = d) and
      // Not inside a parameter list
      not d instanceof Parameter
    }

    /**
     * The given C program element defines the `identifierName` in the given `Scope` and `CNameSpace`.
     */
    predicate isCIdentifier(
      Element e, string identifierName, Scope scope, CNameSpace cNameSpace,
      string identifierDescription
    ) {
      // This only makes sense on C compiled files
      e.getFile().compiledAsC() and
      (
        // An identifier can denote an object; a function; a tag or a member of a structure, union, or
        // enumeration; a typedef name; a label name; a macro name; or a macro parameter
        e.(Declaration).hasName(identifierName) and
        // Exclude any compiler generated identifiers
        not e.(Variable).isCompilerGenerated() and
        not e.(Function).isCompilerGenerated() and
        // Exclude local variables generated by the compiler (but not marked as such by our extractor)
        not e.(LocalScopeVariable).hasName(["__func__", "__PRETTY_FUNCTION__", "__FUNCTION__"]) and
        // Exclude special "macro"
        (
          if isFileScope(e)
          then
            // technically ignoring the function prototype scope, but we don't care for this use case
            scope = FileScope()
          else scope = BlockScope()
        ) and
        (
          if e instanceof UserType
          then
            if e instanceof TypedefType
            then
              // Typedef types are in the ordinary namespace
              cNameSpace = OrdinaryNameSpace()
            else
              // Other user-defined types are in the tag namespace
              cNameSpace = TagNameSpace()
          else
            if (e instanceof MemberVariable or e instanceof MemberFunction)
            then cNameSpace = MemberNameSpace()
            else cNameSpace = OrdinaryNameSpace()
        ) and
        (
          if exists(getDeclDescription(e))
          then identifierDescription = getDeclDescription(e)
          else identifierDescription = "Identifier"
        )
        or
        e.(LabelStmt).getName() = identifierName and
        scope = FunctionScope() and
        cNameSpace = LabelNameSpace() and
        identifierDescription = "Label"
        or
        e.(Macro).hasName(identifierName) and
        scope = MacroScope() and
        cNameSpace = MacroNameSpace() and
        identifierDescription = "Macro"
        or
        e.(FunctionLikeMacro).getAParameter() = identifierName and
        // Exclude __VA_ARGS__ as it is a special macro parameter
        not identifierName = "__VA_ARGS__..." and
        scope = MacroScope() and
        cNameSpace = MacroNameSpace() and
        identifierDescription = "Macro parameter"
        or
        e.(PreprocessorUndef).getName() = identifierName and
        scope = MacroScope() and
        cNameSpace = MacroNameSpace() and
        identifierDescription = "Undef"
      )
    }

    private Macro getGeneratedFrom(Element e) {
      isCIdentifier(e, _, _, _, _) and
      exists(MacroInvocation mi |
        mi = result.getAnInvocation() and
        mi.getAGeneratedElement() = e and
        not exists(MacroInvocation child |
          child.getParentInvocation() = mi and
          child.getAGeneratedElement() = e
        )
      )
    }

    module TargetedCLibrary = CStandardLibrary::C11;

    /**
     * Holds if the given C program element is a reserved identifier according to the C11 standard or MISRA.
     *
     * @param requireHeaderIncluded false if we don't require
     */
    predicate isAReservedIdentifier(Element m, string message, boolean requireHeaderIncluded) {
      requireHeaderIncluded = [true, false] and
      exists(
        string name, Scope scope, CNameSpace cNameSpace, string reason, string identifierDescription
      |
        isCIdentifier(m, name, scope, cNameSpace, identifierDescription) and
        // Exclude cases generated from library macros, because the user does not control them
        not getGeneratedFrom(m) instanceof LibraryMacro and
        message = identifierDescription + " '" + name + "' " + reason + "."
      |
        // C11 7.1.3/1
        //  > All identifiers that begin with an underscore and either an uppercase letter or another
        //  > underscore are always reserved for any use.
        name.regexpMatch("__.*") and
        // Exclude this macro which is intended to be implemented by the user
        not name = "__STDC_WANT_LIB_EXT1__" and
        reason = "declares a reserved name beginning with __"
        or
        name.regexpMatch("_[A-Z].*") and
        reason = "declares a reserved name beginning _ followed by an uppercase letter"
        or
        //  > All identifiers that begin with an underscore are always reserved for use as identifiers
        //  > with file scope in both the ordinary and tag name spaces.
        name.regexpMatch("_([^A-Z_].*)?") and
        scope = FileScope() and
        cNameSpace = [OrdinaryNameSpace().(TCNameSpace), TagNameSpace()] and
        reason =
          "declares a name beginning with _ which is reserved in the " + cNameSpace + " name space"
        or
        name.regexpMatch("_([^A-Z_].*)?") and
        scope = MacroScope() and
        cNameSpace = MacroNameSpace() and
        reason =
          "declares a name beginning with _ which is reserved in the ordinary and tag namespaces"
        or
        // > Each macro name in any of the following subclauses (including the future library
        // > directions) is reserved for use as specified if any of its associated headers is included;
        // > unless explicitly stated otherwise (see 7.1.4).
        exists(string header |
          TargetedCLibrary::hasMacroName(header, name, _) and
          // The relevant header is included directly or transitively by the file, or we don't apply that requirement
          (m.getFile().getAnIncludedFile*().getBaseName() = header or requireHeaderIncluded = false) and
          reason =
            "declares a name reserved for a macro from the " + TargetedCLibrary::getName() +
              " standard library header '" + header + "'"
        )
        or
        // > All identifiers with external linkage in any of the following subclauses (including the
        // > future library directions) and errno are always reserved for use as identifiers with
        // > external linkage.184
        exists(string header |
          TargetedCLibrary::hasObjectName(header, _, name, _, "external")
          or
          TargetedCLibrary::hasFunctionName(header, _, "", name, _, _, "external")
          or
          // > 184. The list of reserved identifiers with external linkage includes math_errhandling, setjmp,
          // > va_copy, and va_end.
          name = "errno" and
          header = "errno.h"
          or
          name = "math_errhandling" and
          header = "math.h"
          or
          name = "setjmp" and
          header = "setjmp.h"
          or
          name = "va_copy" and
          header = "stdarg.h"
          or
          name = "va_end" and
          header = "stdarg.h"
        |
          hasExternalLinkage(m) and
          reason =
            "declares a name which is reserved for external linkage from the " +
              TargetedCLibrary::getName() + " standard library header '" + header + "'"
        )
        or
        // > Each identifier with file scope listed in any of the following subclauses (including the
        // > future library directions) is reserved for use as a macro name and as an identifier with
        // > file scope in the same name space if any of its associated headers is included
        //
        // Note: these cases are typically already rejected by the compiler, which prohibits redeclaration
        //       of existing symbols. The macro cases are expected to work, though.
        exists(string header |
          TargetedCLibrary::hasObjectName(header, _, name, _, _) and
          (cNameSpace = OrdinaryNameSpace() or cNameSpace = MacroNameSpace())
          or
          TargetedCLibrary::hasFunctionName(header, _, "", name, _, _, _) and
          (cNameSpace = OrdinaryNameSpace() or cNameSpace = MacroNameSpace())
          or
          exists(string typeName |
            TargetedCLibrary::hasTypeName(header, _, typeName) and
            // Strip struct/union/enum prefix
            name = typeName.regexpReplaceAll("^(struct|union|enum) ", "")
          |
            (
              if typeName.regexpMatch("^(struct|union|enum) ")
              then
                // struct, union and enum types are in the tag namespace
                cNameSpace = TagNameSpace()
              else
                // typedef and therefore part of the ordinary namespace
                cNameSpace = OrdinaryNameSpace()
            )
            or
            cNameSpace = MacroNameSpace()
          )
          or
          exists(string declaringType, Class c |
            TargetedCLibrary::hasMemberVariableName(header, _, declaringType, name, _)
          |
            // Each declaring type has its own namespace, so check that it's declared in the same
            cNameSpace = MemberNameSpace() and
            c.getAMember() = m and
            c.getSimpleName() = declaringType
            or
            cNameSpace = MacroNameSpace()
          )
        |
          (
            scope = FileScope()
            or
            scope = MacroScope()
          ) and
          // The relevant header is included directly or transitively by the file, or we don't apply that requirement
          (m.getFile().getAnIncludedFile*().getBaseName() = header or requireHeaderIncluded = false) and
          reason =
            "declares a reserved name from the " + TargetedCLibrary::getName() +
              " standard library header '" + header +
              "' which is included directly or indirectly in this translation unit"
        )
        or
        // C11 6.4.1/2
        Keywords::isKeyword(name) and
        reason = "declares a reserved name which is a C11 keyword"
      )
    }
  }

  module Cpp14 {
    private import codingstandards.cpp.Lex

    module TargetedCppLibrary = CppStandardLibrary::Cpp14;

    module TargetedCLibrary = CStandardLibrary::C99;

    predicate isMacroUsingReservedIdentifier(PreprocessorDirective pd, string reason) {
      exists(string name, string identifierDescription |
        pd.(Macro).getName() = name and identifierDescription = "#define"
        or
        pd.(PreprocessorUndef).getName() = name and
        identifierDescription = "#undef"
      |
        // [macro.names] precludes the use of any name declared in any standard library header
        exists(string header, string standard |
          TargetedCLibrary::hasName(header, name) and
          standard = TargetedCLibrary::getName()
          or
          TargetedCppLibrary::hasName(header, name) and
          standard = TargetedCppLibrary::getName()
        |
          // Includes at least one standard library header
          pd.getFile().getAnIncludedFile*().getBaseName() =
            [TargetedCLibrary::getAHeader(), TargetedCppLibrary::getAHeader()] and
          reason =
            "'" + identifierDescription + " " + name + "' uses a reserved name from the " + standard
              + " standard library header <" + header + ">."
        )
        or
        // [macro.names] precludes the use of keywords, special identifiers or reserved attribute tokens
        exists(string kind |
          name = Lex::Cpp14::keyword() and kind = " keyword"
          or
          name = Lex::Cpp14::specialIdentfier() and kind = "special identifier"
          or
          name = Lex::Cpp14::reservedAttributeToken() and kind = "reserved attribute token"
        |
          reason =
            "'" + identifierDescription + " " + name + "' uses a name lexically identical to a " +
              kind + "."
        )
        or
        // [global.names] Reserves unconditionally all names containing __ or prefixed with _[A-Z].
        // In addition _ prefixed names are reserved to the implementation in the global namespace.
        // As macros are not limited in effect to a given namespace, we also consider all names
        // starting with _ as reserved when considering macros, as well as those with __ in the name.
        name.regexpMatch("(_.*|.*__.*)") and
        reason =
          "'" + identifierDescription + " " + name + "' uses a name reserved for the " +
            TargetedCppLibrary::getName() + " implementation."
      )
    }

    class GlobalFunction extends TopLevelFunction {
      GlobalFunction() { getNamespace() instanceof GlobalNamespace }
    }

    private Macro getGeneratedFrom(Element e) {
      isCppIdentifier(e, _, _, _) and
      exists(MacroInvocation mi |
        mi = result.getAnInvocation() and
        mi.getAGeneratedElement() = e and
        not exists(MacroInvocation child |
          child.getParentInvocation() = mi and
          child.getAGeneratedElement() = e
        )
      )
    }

    newtype IdentifierScope =
      StdNamespaceScope() or
      GlobalNamespaceScope() or
      OtherNamespaceScope()

    /**
     * An declaration whose name can be reserved.
     */
    private predicate isCppIdentifier(
      Declaration m, string name, string identifierDescription, IdentifierScope scope
    ) {
      m.(GlobalFunction).getName() = name and
      identifierDescription = "Function" and
      scope = GlobalNamespaceScope()
      or
      m.(GlobalVariable).getName() = name and
      identifierDescription = "Variable" and
      scope = GlobalNamespaceScope()
      or
      m.(UserType).getName() = name and
      m.(UserType).getNamespace() instanceof GlobalNamespace and
      identifierDescription = "Type" and
      scope = GlobalNamespaceScope()
      or
      hasExternalLinkage(m) and
      m.(Declaration).getName() = name and
      identifierDescription = "Declaration with external linkage" and
      exists(Namespace n | n = m.(Declaration).getNamespace() |
        if n instanceof StdNS
        then scope = StdNamespaceScope()
        else
          if n instanceof GlobalNamespace
          then scope = GlobalNamespaceScope()
          else scope = OtherNamespaceScope()
      )
    }

    predicate isAReservedIdentifier(Declaration m, string message) {
      exists(string name, string identifierDescription, IdentifierScope scope, string reason |
        isCppIdentifier(m, name, identifierDescription, scope) and
        // Exclude cases generated from library macros, because the user does not control them
        not getGeneratedFrom(m) instanceof LibraryMacro and
        message = identifierDescription + " '" + name + "' " + reason + "."
      |
        // [global.names] reserves unconditionally all names containing __ or prefixed with _[A-Z].
        // In addition _ prefixed names are reserved to the implementation in the global namespace.
        name.regexpMatch("(_[A-Z].*|.*__.*)") and
        reason =
          " uses a name reserved for the " + TargetedCppLibrary::getName() + " implementation."
        or
        // [global.names] reserves all _ prefixed names to the implementation in the global namespace.
        name.regexpMatch("_([^A-Z_].*)?") and
        scope = GlobalNamespaceScope() and
        reason =
          " uses a name reserved for the " + TargetedCppLibrary::getName() + " implementation."
        or
        // [extern.names]/1:
        //   Each name declared as an object with external linkage in a header is reserved to the implementation to
        //   designate that library object with external linkage,182 both in namespace std and in the global namespace.
        exists(string header |
          header =
            max(string candidate_header |
              TargetedCppLibrary::hasObjectName(candidate_header, _, name, _, "external")
            )
          or
          header = "errno" and
          name = "cerrno"
        |
          not scope = OtherNamespaceScope() and
          reason =
            "declares a reserved object name from the " + TargetedCppLibrary::getName() +
              " standard library header <" + header + ">"
        )
        or
        // [extern.names]/2:
        //   Each global function signature declared with external linkage in a header is reserved to the implementation
        //   to designate that function signature with external linkage.
        exists(string header |
          header =
            max(string candidate_header |
              // Global functions are in the global namespace ("") and have no declaring type
              TargetedCppLibrary::hasFunctionName(candidate_header, "", "", name, _, _, "external")
            )
          or
          header = "csetjmp" and
          name = "setjmp"
          or
          header = "cstdarg" and
          name = "va_end"
        |
          // Only report against elements with external linkage
          hasExternalLinkage(m) and
          reason =
            "declares a name which is reserved for a function from the " +
              TargetedCppLibrary::getName() + " standard library header <" + header + ">"
        )
        or
        // [extern.names]/3:
        //   Each name from the Standard C library declared with external linkage is reserved to the implementation
        //   for use as a name with extern "C" linkage, both in namespace std and in the global namespace.
        exists(string header |
          header =
            max(string candidate_header |
              TargetedCLibrary::hasObjectName(candidate_header, _, name, _, "external")
            )
        |
          // Only global and std
          not scope = OtherNamespaceScope() and
          reason =
            "declares a name which is reserved for the " + TargetedCLibrary::getName() +
              " standard library header <" + header + ">"
        )
        or
        exists(string header |
          // [extern.names]/4:
          //   Each function signature from the Standard C library declared with external linkage is reserved to the
          //   implementation for use as a function signature with both extern "C" and extern "C++" linkage, 184 or as
          //   a name of namespace scope in the global namespace.
          header =
            max(string candidate_header |
              TargetedCLibrary::hasFunctionName(candidate_header, _, _, name, _, _, "external")
            ) and
          reason =
            "declares a name which is reserved for a function from the " +
              TargetedCLibrary::getName() + " standard library header <" + header + ">"
          or
          header = ["cuchar", "cwchar", "cwctype"] and
          TargetedCppLibrary::hasFunctionName(header, _, "", name, _, _, "external") and
          reason =
            "declares a name which is reserved for a function from the " +
              TargetedCppLibrary::getName() + " standard library header <" + header + ">"
        |
          // Only reserved as a name in the global scope
          scope = GlobalNamespaceScope()
          or
          // Not a function, but has external linkage
          hasExternalLinkage(m) and
          not m instanceof Function
        )
        or
        exists(string header |
          // [extern.types]:
          //   For each type T from the Standard C library,185 the types ::T and std::T are reserved to the implementation
          // and, when defined, ::T shall be identical to std::T.
          header =
            max(string candidate_header | TargetedCLibrary::hasTypeName(candidate_header, _, name)) and
          // Only restricted in std and global namespace
          not scope = OtherNamespaceScope() and
          reason =
            "declares a name which is reserved for a type from the " + TargetedCLibrary::getName() +
              " standard library header <" + header + ">"
        )
      )
    }
  }
}
