/**
 * A module for identifying useless assignments.
 */

import cpp
import codingstandards.cpp.enhancements.ControlFlowGraphEnhancements

/** If a variable may escape from the local context */
predicate mayEscape(StackVariable v) {
  v.(Parameter).getType().getUnspecifiedType() instanceof ReferenceType
}

/**
 * Holds if the `ultimateDef` and `v` are an SSA definition of a variable which would be interesting
 * to flag as unused.
 */
predicate isInterestingSsaDefinition(SsaDefinition ultimateDef, InterestingStackVariable v) {
  ultimateDef.getAVariable() = v and
  // Phi nodes are not user supplied definitions
  not ultimateDef.isPhiNode(v) and
  // Ignore parameters, because they can be unused, but they are defined in a non-local way
  not ultimateDef.definedByParameter(_) and
  // Exclude definitions created by passing values to other functions, because:
  //  (1) SSA makes assumptions around whether such calls write to local variables, which can
  //      cause FPs for this query when the variable is not actually written to.
  //  (2) SSA also confuses pointers with the thing they point to. So it can say an argument to a
  //      function call is a definition of a variable, when, in fact, it defines the thing the
  //      variable points-to.
  not ultimateDef.getDefinition() = any(Call c).getAnArgument() and
  // Ignore `new` expressions which call a constructor, which may have side-effects
  not ultimateDef.getDefinition().(NewExpr).getInitializer() instanceof Call
}

/**
 * A `StackVariable` which is interesting to flag as unused.
 */
class InterestingStackVariable extends StackVariable {
  InterestingStackVariable() {
    // Rule only requires non-volatile variables
    not isVolatile() and
    // A variable generated by a macro may be unused, but often macros are not controlled by the user
    not isAffectedByMacro() and
    // A reference parameter can have an affect outside the enclosing function
    not mayEscape(this) and
    // Not a loop control variable, explicitly excluded
    not this instanceof LoopControlVariable
  }
}

/*
 * The strategy for this query is to find SSA definitions which are never meaningfully used (i.e.
 * outside a phi node).
 *
 * It is limited in the following ways:
 *  - It is restricted to stack variables. In particular, it does not consider globals or fields
 *  - It only considers assignments and uses in the local scope of a single function
 */

predicate isUselessSsaDefinition(SsaDefinition ultimateDef, InterestingStackVariable v) {
  isInterestingSsaDefinition(ultimateDef, v) and
  // No SsaDefinition which uses the value of ultimate def
  not exists(SsaDefinition d |
    ultimateDef = d.getAnUltimateSsaDefinition(v) and
    exists(d.getAUse(v))
  ) and
  // Ignore this definition if the function is suspected to have an invaild control flow graph
  not hasInvalidCFG(v.getFunction())
}
