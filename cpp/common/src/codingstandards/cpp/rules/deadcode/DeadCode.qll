/**
 * Provides a library which includes a `problems` predicate for reporting DeadCode.
 *
 * This problems predicate finds the following kinds of dead code statement:
 * - A declaration of a non-static stack variable whose initializing expression is pure and that is never subsequently accessed in live code.
 * - A block that contain only dead statements.
 * - A do loop whose condition is pure, and whose body contains only dead statements.
 * - An if statement whose condition is pure, and whose then and else clauses (where they exist) only contain dead statements.
 * - A while loop whose condition is pure, and whose body contains only dead statements.
 * - Expression statements whose expressions are pure.
 * - Writes to a non-static stack variable that is never subsequently read in live code.
 */

import cpp
import codingstandards.cpp.alertreporting.HoldsForAllCopies
import codingstandards.cpp.Customizations
import codingstandards.cpp.Exclusions
import codingstandards.cpp.deadcode.UselessAssignments
import codingstandards.cpp.deadcode.UnreachableCode
import codingstandards.cpp.deadcode.UnusedVariables

abstract class DeadCodeSharedQuery extends Query { }

Query getQuery() { result instanceof DeadCodeSharedQuery }

/**
 * Holds if the `Stmt` `s` is either dead or unreachable.
 */
predicate isDeadOrUnreachableStmt(Stmt s) {
  isDeadStmt(s)
  or
  s.getBasicBlock() = any(UnreachableBasicBlock ubb).getABasicBlock()
}

predicate isDeadStmt(Stmt s) {
  // A `DeclStmt` is dead code if:
  // - All the declarations are variable declarations
  // - None of those variables are ever accessed in non-dead code
  // - The initializers for each of the variables are pure
  // - It isn't constexpr and used to declare an array size
  exists(DeclStmt ds |
    ds = s and
    // Use forex so that we don't flag "fake" generated `DeclStmt`s (e.g. those generated by the
    // extractor for static_asserts) with no actual declarations
    forex(Declaration d | d = ds.getADeclaration() |
      exists(LocalScopeVariable v |
        d = v and
        v.getInitializer().getExpr().isPure() and
        not exists(VariableAccess va |
          va.getTarget() = v and
          not isDeadOrUnreachableStmt(va.getEnclosingStmt())
        ) and
        not countUsesInLocalArraySize(v) > 0
      )
    )
  )
  or
  // A block that only contains dead statements.
  exists(BlockStmt b |
    b = s and
    forall(Stmt child | child = b.getAStmt() | isDeadStmt(child)) and
    // If this is a catch block, we should only report it as dead if it is the last catch block.
    not exists(TryStmt ts, int i |
      ts.getCatchClause(i) = b and
      i < (ts.getNumberOfCatchClauses() - 1)
    )
  )
  or
  // A do statement whose condition is pure, and whose body contains only dead statements.
  exists(DoStmt ds |
    ds = s and
    ds.getCondition().isPure() and
    isDeadOrUnreachableStmt(ds.getStmt())
  )
  or
  // An if statement whose condition is pure, and whose then and else clauses (where they exist) are dead or unreachable
  exists(IfStmt is |
    is = s and
    is.getCondition().isPure() and
    // Then part is either dead or unreachable
    isDeadOrUnreachableStmt(is.getThen()) and
    (exists(is.getElse()) implies isDeadOrUnreachableStmt(is.getElse()))
  )
  or
  // A while statement whose condition is pure, and whose body is a dead or unreachable statement
  exists(WhileStmt ws |
    ws = s and
    ws.getCondition().isPure() and
    isDeadOrUnreachableStmt(ws.getStmt())
  )
  or
  // An expression statement which is pure
  s.(ExprStmt).getExpr().isPure()
  or
  exists(SsaDefinition sd, LocalScopeVariable v |
    // A useless definition
    isUselessSsaDefinition(sd, v) and
    s.(ExprStmt).getExpr() = sd.getDefinition() and
    // The defining value is pure
    sd.getDefiningValue(v).isPure()
  )
  or
  // Any TryStmt with a dead body is dead. We ignore the catch blocks, because if the body is dead,
  // no exception can be thrown, and so the catch blocks are unreachable
  exists(TryStmt ts | s = ts and isDeadStmt(ts.getStmt()))
}

/**
 * Holds if the `Stmt` `s` is dead, i.e. could be executed, but its removal would not meaningfully
 * affect the program.
 */
class DeadStmtInstance extends Stmt {
  DeadStmtInstance() {
    isDeadStmt(this) and
    // Exclude compiler generated statements
    not this.isCompilerGenerated() and
    // Exclude code fully generated by macros, because the code may be "live" in other expansions
    isNotWithinMacroExpansion(this) and
    // MISRA defines dead code as an "_executed_ statement whose removal would not affect the program
    // output". We therefore exclude unreachable statements as they are, by definition, not executed.
    not this.getBasicBlock() = any(UnreachableBasicBlock ubb).getABasicBlock()
  }
}

class DeadStmt = HoldsForAllCopies<DeadStmtInstance, Stmt>::LogicalResultElement;

query predicate problems(DeadStmt s, string message) {
  not isExcluded(s.getAnElementInstance(), getQuery()) and
  message = "This statement is dead code." and
  // Report only the highest level dead statement, to avoid over reporting
  not exists(DeadStmt parent |
    // All instances must share a dead statement parent for us to report the parent instead
    forall(Stmt instance | instance = s.getAnElementInstance() |
      parent.getAnElementInstance() = instance.getParentStmt()
    )
  )
}
